"use strict";
(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
    [9764], {
        84716: function(e, t, i) {
            function n(e, t) {
                return Object.assign(Object.create(t), e)
            }

            function o(e, t) {
                return e ? /^-?\d+px$/.test(e) ? parseInt(e) : /^-?\d+vh$/.test(e) ? parseInt(e) * t.viewportHeight / 100 : /^-?\d+vw$/.test(e) ? parseInt(e) * t.viewportWidth / 100 : parseInt(e) || 0 : 0
            }

            function s(e, t, i) {
                const {
                    name: n,
                    offset: o = 0
                } = e, {
                    start: s,
                    end: r
                } = i, c = r - s, f = o / 100;
                let h, d;
                return "entry" === n ? (h = s - t, d = Math.min(t, c)) : "contain" === n ? (h = Math.min(r - t, s), d = Math.abs(t - c)) : "exit" === n ? (h = Math.max(s, r - t), d = Math.min(t, c)) : "cover" === n && (h = s - t, d = c + t), h + f * d | 0
            }

            function r(e) {
                return "sticky" === e.position
            }

            function c(e, t, i) {
                i && (e.style.position = "static");
                const n = (t ? e.offsetLeft : e.offsetTop) || 0;
                return i && (e.style.position = null), n
            }

            function f(e, t) {
                let i;
                const n = function(e, t) {
                        return parseInt(t ? e.left : e.top)
                    }(e, t),
                    o = function(e, t) {
                        return parseInt(t ? e.right : e.bottom)
                    }(e, t),
                    s = !isNaN(n),
                    r = !isNaN(o);
                return (s || r) && (i = {}, s && (i.start = n), r && (i.end = o)), i
            }

            function h(e, t, i, n, h) {
                const d = e.viewSource,
                    l = window.getComputedStyle(d),
                    a = r(l),
                    u = a ? f(l, n) : void 0;
                let w = d.offsetParent,
                    p = 0,
                    v = "fixed" === l.position;
                const g = c(d, n, a);
                u && "end" in u || (p += g);
                const m = (n ? d.offsetWidth : d.offsetHeight) || 0,
                    y = [{
                        element: d,
                        offset: g,
                        size: m,
                        sticky: u,
                        style: a ? l : null
                    }];
                for (; w;) {
                    if (w === t) {
                        y.push({
                            element: w,
                            offset: 0
                        });
                        break
                    }
                    const e = window.getComputedStyle(w),
                        i = r(e),
                        o = i ? f(e, n) : void 0,
                        s = c(w, n, i);
                    o && "end" in o || (p += s), y.push({
                        element: w,
                        offset: s,
                        sticky: o
                    }), w = w.offsetParent, w || (v = "fixed" === e.position)
                }
                y.reverse();
                const E = function(e, t, i, n, r) {
                    const {
                        start: c,
                        end: f,
                        duration: h
                    } = e;
                    let d, l = c,
                        a = f,
                        u = e.startRange,
                        w = e.endRange;
                    if ("string" == typeof h) u = {
                        name: h,
                        offset: 0
                    }, w = {
                        name: h,
                        offset: 100
                    }, l = s(u, i, t), a = s(w, i, t), d = a - l;
                    else {
                        if (u || c ? .name) {
                            u = u || c;
                            const e = o(u.add, r);
                            l = s(u, i, t) + e
                        }
                        if (w || f ? .name) {
                            w = w || f;
                            const e = o(w.add, r);
                            a = s(w, i, t) + e
                        } else "number" == typeof h && (a = l + h)
                    }
                    return { ...e,
                        start: l,
                        end: a,
                        startRange: u,
                        endRange: w,
                        duration: d || h
                    }
                }(e, {
                    start: p,
                    end: p + m
                }, i, 0, h);
                E.isFixed = v;
                let x = 0;
                return y.forEach(((e, t) => {
                    x += e.offset;
                    const o = e.sticky;
                    if (o) {
                        if ("end" in o) {
                            const s = y[t - 1] ? .element;
                            if (s) {
                                const t = ((n ? e.element.offsetWidth : e.element.offsetHeight) || 0) + o.end - i,
                                    s = x + t - e.offset,
                                    r = s < E.start,
                                    c = !r && s <= E.end;
                                let f = 0;
                                (r || c) && (f = e.offset, E.end += f), r && (E.start += f)
                            }
                        }
                        if ("start" in o) {
                            const i = x - o.start,
                                s = i < E.start,
                                r = !s && i <= E.end;
                            let c = 0;
                            const f = y[t - 1] ? .element;
                            if (f) {
                                if (s || r) {
                                    c = ((n ? f.offsetWidth : f.offsetHeight) || 0) - (e.offset + ((n ? e.element.offsetWidth : e.element.offsetHeight) || 0)), x += c, E.end += c
                                }
                                s && (E.start += c)
                            }
                        }
                    }
                })), E
            }
            i.d(t, {
                o: function() {
                    return p
                }
            });
            const d = {
                horizontal: !1,
                observeViewportEntry: !0,
                viewportRootMargin: "7% 7%",
                observeViewportResize: !1,
                observeSourcesResize: !1
            };

            function l(e, t, i, n) {
                let o = 0;
                return e >= t && e <= i ? o = n ? (e - t) / n : 1 : e > i && (o = 1), o
            }

            function a(e, t) {
                return e === window ? window.visualViewport ? t ? window.visualViewport.width : window.visualViewport.height : t ? window.document.documentElement.clientWidth : window.document.documentElement.clientHeight : t ? e.clientWidth : e.clientHeight
            }

            function u(e) {
                const t = n(e, d),
                    i = t.root,
                    o = t.horizontal,
                    s = new WeakMap;
                let r, c, f, u, w, p = a(i, o);
                const v = [],
                    g = {
                        viewportWidth: window.visualViewport.width,
                        viewportHeight: window.visualViewport.height
                    };
                if (t.scenes = e.scenes.map(((e, n) => (e.index = n, e.viewSource && ("string" == typeof e.duration || e.start ? .name) ? (e = h(e, i, p, o, g), t.observeSourcesResize && v.push(e)) : null == e.end && (e.end = e.start + e.duration), null == e.duration && (e.duration = e.end - e.start), e))), v.length) {
                    if (window.ResizeObserver) {
                        const e = new Map;
                        f = new window.ResizeObserver((function(n) {
                            n.forEach((n => {
                                const s = e.get(n.target);
                                t.scenes[s.index] = h(s, i, p, o, g), v.splice(v.indexOf(s), 1, t.scenes[s.index])
                            }))
                        })), v.forEach((t => {
                            f.observe(t.viewSource, {
                                box: "border-box"
                            }), e.set(t.viewSource, t)
                        }))
                    }
                    t.observeViewportResize && (u = function(e, t) {
                        let i = 0;
                        return function() {
                            i && window.clearTimeout(i), i = window.setTimeout((() => {
                                i = 0, e()
                            }), t)
                        }
                    }((function() {
                        p = a(i, o);
                        const e = v.map((e => {
                            const n = h(e, i, p, o, g);
                            return t.scenes[e.index] = n, n
                        }));
                        v.length = 0, v.push(...e)
                    }), 100), i === window ? (window.visualViewport || window).addEventListener("resize", u) : window.ResizeObserver && (w = new window.ResizeObserver(u), w.observe(i, {
                        box: "border-box"
                    })))
                }
                return t.observeViewportEntry && window.IntersectionObserver && (c = new window.IntersectionObserver((function(e) {
                    e.forEach((e => {
                        (s.get(e.target) || []).forEach((t => {
                            t.disabled = !e.isIntersecting
                        }))
                    }))
                }), {
                    root: i === window ? window.document : i,
                    rootMargin: t.viewportRootMargin,
                    threshold: 0
                }), t.scenes.forEach((e => {
                    if (e.viewSource) {
                        let t = s.get(e.viewSource);
                        t || (t = [], s.set(e.viewSource, t), c.observe(e.viewSource)), t.push(e)
                    }
                }))), {
                    tick: function({
                        p: e,
                        vp: i
                    }) {
                        e = +e.toFixed(1);
                        const n = +i.toFixed(4);
                        if (e !== r) {
                            for (let i of t.scenes)
                                if (!i.disabled) {
                                    const {
                                        start: t,
                                        end: o,
                                        duration: s
                                    } = i, r = l(e, t, o, s);
                                    i.effect(i, r, n), i.isFixed && (i.disabled = !0)
                                }
                            r = e
                        }
                    },
                    destroy: function() {
                        t.scenes.forEach((e => e.destroy ? .())), c && (c.disconnect(), c = null), f && (f.disconnect(), f = null), u && (w ? (w.disconnect(), w = null) : (window.visualViewport || window).removeEventListener("resize", u))
                    }
                }
            }
            const w = {
                transitionActive: !1,
                transitionFriction: .9,
                transitionEpsilon: 1,
                velocityActive: !1,
                velocityMax: 1
            };
            class p {
                constructor(e = {}) {
                    this.config = n(e, w), this.progress = {
                        p: 0,
                        prevP: 0,
                        vp: 0
                    }, this.currentProgress = {
                        p: 0,
                        prevP: 0,
                        vp: 0
                    }, this._lerpFrameId = 0, this.effect = null, this.config.root = this.config.root && this.config.root !== window.document.body ? this.config.root : window, this.config.resetProgress = this.config.resetProgress || this.resetProgress.bind(this), this._measure = this.config.measure || (() => {
                        const e = this.config.root;
                        this.progress.p = this.config.horizontal ? e.scrollX || e.scrollLeft || 0 : e.scrollY || e.scrollTop || 0
                    }), this._trigger = function(e) {
                        let t = !1;
                        return function() {
                            t || (t = !0, window.requestAnimationFrame((() => {
                                t = !1, e()
                            })))
                        }
                    }((() => {
                        this._measure ? .(), this.tick(!0)
                    }))
                }
                start() {
                    this.setupEffect(), this.setupEvent(), this.resetProgress(), this.tick()
                }
                pause() {
                    this.removeEvent()
                }
                resetProgress(e = {}) {
                    const t = this.config.root,
                        i = e.x || 0 === e.x ? e.x : t.scrollX || t.scrollLeft || 0,
                        n = e.y || 0 === e.y ? e.y : t.scrollY || t.scrollTop || 0,
                        o = this.config.horizontal ? i : n;
                    this.progress.p = o, this.progress.prevP = o, this.progress.vp = 0, this.config.transitionActive && (this.currentProgress.p = o, this.currentProgress.prevP = o, this.currentProgress.vp = 0), e && this.config.root.scrollTo(i, n)
                }
                tick(e) {
                    const t = this.config.transitionActive;
                    t && this.lerp();
                    const i = t ? this.currentProgress : this.progress;
                    if (this.config.velocityActive) {
                        const e = i.p - i.prevP,
                            t = e < 0 ? -1 : 1;
                        i.vp = Math.min(this.config.velocityMax, Math.abs(e)) / this.config.velocityMax * t
                    }
                    this.effect.tick(i), t && i.p !== this.progress.p && (e && this._lerpFrameId && window.cancelAnimationFrame(this._lerpFrameId), this._lerpFrameId = window.requestAnimationFrame((() => this.tick()))), i.prevP = i.p
                }
                lerp() {
                    this.currentProgress.p = function(e, t, i, n) {
                        let o = e * (1 - i) + t * i;
                        if (n) {
                            const i = o - e;
                            Math.abs(i) < n && (o = e + n * Math.sign(i));
                            const s = t - o;
                            if (Math.abs(s) < n) return t
                        }
                        return o
                    }(this.currentProgress.p, this.progress.p, +(1 - this.config.transitionFriction).toFixed(3), this.config.transitionEpsilon)
                }
                destroy() {
                    this.pause(), this.removeEffect()
                }
                setupEvent() {
                    this.removeEvent(), this.config.root.addEventListener("scroll", this._trigger)
                }
                removeEvent() {
                    this.config.root.removeEventListener("scroll", this._trigger)
                }
                setupEffect() {
                    this.removeEffect(), this.effect = u(this.config)
                }
                removeEffect() {
                    this.effect && this.effect.destroy(), this.effect = null
                }
            }
        },
        85668: function(e, t, i) {
            i.d(t, {
                g: function() {
                    return f
                }
            });
            if (!("undefined" == typeof window || "onscrollend" in window)) {
                const h = new Event("scrollend"),
                    d = new Set;
                document.addEventListener("touchstart", (e => {
                    for (let t of e.changedTouches) d.add(t.identifier)
                }), {
                    passive: !0
                }), document.addEventListener("touchend", (e => {
                    for (let t of e.changedTouches) d.delete(t.identifier)
                }), {
                    passive: !0
                });
                let l = new WeakMap;

                function a(e, t, i) {
                    let n = e[t];
                    e[t] = function() {
                        let e = Array.prototype.slice.apply(arguments, [0]);
                        n.apply(this, e), e.unshift(n), i.apply(this, e)
                    }
                }

                function u(e, t, i, n) {
                    if ("scroll" != t && "scrollend" != t) return;
                    let o = this,
                        s = l.get(o);
                    if (void 0 === s) {
                        let t = 0;
                        s = {
                            scrollListener: e => {
                                clearTimeout(t), t = setTimeout((() => {
                                    d.size ? setTimeout(s.scrollListener, 100) : (o && o.dispatchEvent(h), t = 0)
                                }), 100)
                            },
                            listeners: 0
                        }, e.apply(o, ["scroll", s.scrollListener]), l.set(o, s)
                    }
                    s.listeners++
                }

                function w(e, t, i) {
                    if ("scroll" != t && "scrollend" != t) return;
                    let n = this,
                        o = l.get(n);
                    void 0 !== o && (o[t]--, --o.listeners > 0 || (e.apply(n, ["scroll", o.scrollListener]), l.delete(n)))
                }
                a(Element.prototype, "addEventListener", u), a(window, "addEventListener", u), a(document, "addEventListener", u), a(Element.prototype, "removeEventListener", w), a(window, "removeEventListener", w), a(document, "removeEventListener", w)
            }

            function n(e, t, i) {
                return Math.min(Math.max(e, i), t)
            }
            const o = {
                x: 0,
                y: 0
            };

            function s(e, t) {
                o.x = window.scrollX, o.y = window.scrollY, requestAnimationFrame((() => e && e(t)))
            }

            function r(e) {
                e.rect.width = window.visualViewport.width, e.rect.height = window.visualViewport.height
            }

            function c(e) {
                let t, i, c, f, h = !1,
                    d = {
                        x: e.rect.width / 2,
                        y: e.rect.height / 2,
                        vx: 0,
                        vy: 0
                    };
                return e.scenes.forEach((t => {
                    var n, s;
                    t.target && t.centeredToTarget && (t.transform = (n = function(e) {
                        let t = e,
                            i = 0,
                            n = 0;
                        if (t.offsetParent)
                            do {
                                i += t.offsetLeft, n += t.offsetTop, t = t.offsetParent
                            } while (t);
                        return {
                            left: i,
                            top: n,
                            width: e.offsetWidth,
                            height: e.offsetHeight
                        }
                    }(t.target), s = e.rect, {
                        x(e) {
                            const t = n.left - o.x + n.width / 2,
                                i = t >= s.width / 2,
                                r = 2 * (i ? t : s.width - t);
                            return (e - (i ? 0 : t - r / 2)) / r
                        },
                        y(e) {
                            const t = n.top - o.y + n.height / 2,
                                i = t >= s.height / 2,
                                r = 2 * (i ? t : s.height - t);
                            return (e - (i ? 0 : t - r / 2)) / r
                        }
                    }), h = !0), e.root ? i = function(e) {
                        const t = new ResizeObserver((t => {
                            t.forEach((t => {
                                e.rect.width = t.borderBoxSize[0].inlineSize, e.rect.height = t.borderBoxSize[0].blockSize
                            }))
                        }));
                        return t.observe(e.root, {
                            box: "border-box"
                        }), t
                    }(e) : (c = r.bind(null, e), window.addEventListener("resize", c))
                })), t = function(t) {
                    for (let i of e.scenes)
                        if (!i.disabled) {
                            const o = +n(0, 1, i.transform ? .x(t.x) || t.x / e.rect.width).toPrecision(4),
                                s = +n(0, 1, i.transform ? .y(t.y) || t.y / e.rect.height).toPrecision(4),
                                r = {
                                    x: t.vx,
                                    y: t.vy
                                };
                            i.effect(i, {
                                x: o,
                                y: s
                            }, r)
                        }
                    Object.assign(d, t)
                }, h && (f = s.bind(null, t, d), document.addEventListener("scrollend", f)), {
                    tick: t,
                    destroy: function() {
                        e.scenes.forEach((e => e.destroy ? .())), document.removeEventListener("scrollend", f), i ? (i.disconnect(), i = null) : (window.removeEventListener("resize", c), c = null), t = null, d = null
                    }
                }
            }
            class f {
                constructor(e = {}) {
                    this.config = { ...e
                    }, this.effect = null, this._nextTick = null;
                    const t = function(e) {
                        let t = !1;
                        return function() {
                            if (!t) return t = !0, window.requestAnimationFrame((() => {
                                t = !1, e()
                            }))
                        }
                    }((() => {
                        this.tick()
                    }));
                    this.config.rect = this.config.root ? {
                        width: this.config.root.offsetWidth,
                        height: this.config.root.offsetHeight
                    } : {
                        width: window.visualViewport.width,
                        height: window.visualViewport.height
                    }, this.progress = {
                        x: this.config.rect.width / 2,
                        y: this.config.rect.height / 2,
                        vx: 0,
                        vy: 0
                    }, this._measure = e => {
                        this.progress.x = this.config.root ? e.offsetX : e.x, this.progress.y = this.config.root ? e.offsetY : e.y, this.progress.vx = e.movementX, this.progress.vy = e.movementY, this._nextTick = t()
                    }
                }
                start() {
                    this.setupEffect(), this.setupEvent()
                }
                pause() {
                    this.removeEvent()
                }
                tick() {
                    this.effect.tick(this.progress)
                }
                destroy() {
                    this.pause(), this.removeEffect(), this._nextTick && cancelAnimationFrame(this._nextTick)
                }
                setupEvent() {
                    this.removeEvent();
                    (this.config.root || window).addEventListener("pointermove", this._measure, {
                        passive: !0
                    })
                }
                removeEvent() {
                    (this.config.root || window).removeEventListener("pointermove", this._measure)
                }
                setupEffect() {
                    this.removeEffect(), this.effect = c(this.config)
                }
                removeEffect() {
                    this.effect && this.effect.destroy(), this.effect = null
                }
            }
        }
    }
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/9764.fd6182af.chunk.min.js.map