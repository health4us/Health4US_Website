"use strict";
(self.webpackJsonp__wix_thunderbolt_app = self.webpackJsonp__wix_thunderbolt_app || []).push([
    [1212], {
        24328: function(t, e, n) {
            n.r(e), n.d(e, {
                ScreenInAPISymbol: function() {
                    return m.aG
                },
                page: function() {
                    return y
                }
            });
            var i = n(23604),
                s = n(90608),
                o = n(82560),
                a = n(89908),
                r = n(27956),
                c = n(25183);
            const d = t => `${t}-screenIn`;
            class l {
                constructor(t) {
                    this.animator = t, this.definitions = {}, this.sessionState = {
                        played: new Map,
                        running: new Map
                    }
                }
                _shouldSkipPlayedAnimation(t) {
                    const e = this.sessionState.played.has(t),
                        {
                            playOnce: n,
                            persistOnNav: i
                        } = this.sessionState.played.get(t) || {};
                    return e && (n || i)
                }
                _hideComponent(t) {
                    const e = document.querySelector(`#${t}`);
                    if (e) e.style.opacity = "0";
                    else {
                        const e = Array.from(document.querySelectorAll(`[id^="${t}__"]`));
                        e ? .length && e.forEach((t => {
                            t.style.opacity = "0"
                        }))
                    }
                }
                unhideComponent(t) {
                    const e = document.querySelector(`#${t}`);
                    if (e) e.dataset.screenInHide = "done", e.style.opacity = "", e.style.visibility = "inherit";
                    else {
                        const e = Array.from(document.querySelectorAll(`[id^="${t}__"]`));
                        e ? .length && e.forEach((t => {
                            t.dataset.screenInHide = "done", t.style.opacity = "", t.style.visibility = "inherit"
                        }))
                    }
                }
                _addAnimatingClass(t) {
                    const e = document.getElementById(t);
                    if (e) e.classList.add("is-animating"), e.dataset.screenInHide = "done";
                    else {
                        const e = Array.from(document.querySelectorAll(`[id^="${t}__"]`));
                        e ? .length && e.forEach((t => {
                            t.classList.add("is-animating"), t.dataset.screenInHide = "done"
                        }))
                    }
                }
                _removeAnimatingClass(t) {
                    const e = document.getElementById(t);
                    if (e) e.classList.remove("is-animating"), e.dataset.screenInHide = "done";
                    else {
                        const e = Array.from(document.querySelectorAll(`[id^="${t}__"]`));
                        e ? .length && e.forEach((t => {
                            t.classList.remove("is-animating"), t.dataset.screenInHide = "done"
                        }))
                    }
                }
                updateDefinitions(t) {
                    this.definitions = { ...this.definitions,
                        ...t
                    }
                }
                _hideCompBeforeAnimation(t) {
                    const e = d(t);
                    this._shouldSkipPlayedAnimation(e) ? this.unhideComponent(t) : this._hideComponent(t)
                }
                hideBeforeAnimation(t) {
                    this.getCompsToHide(t).forEach((({
                        compId: t
                    }) => {
                        this._hideCompBeforeAnimation(t)
                    }))
                }
                handleRotation(t, e) {
                    t.setAttribute("data-angle", String(e)), t.setAttribute("data-angle-style-location", "style")
                }
                trigger(t = []) {
                    t.reduce(((t, {
                        compId: e
                    }) => {
                        const n = this.definitions[e] || [];
                        return t.concat(n)
                    }), []).forEach((({
                        action: t,
                        ...e
                    }) => this.executeAnimation(t, e)))
                }
                init(t) {
                    this.updateDefinitions(t), this.stopAnimations(), this.hideBeforeAnimation(t)
                }
                addDefinition(t, e, n) {
                    this.handleRotation(e, n), this.updateDefinitions(t)
                }
                executeAnimation(t, {
                    name: e,
                    targetId: n,
                    duration: i = 0,
                    delay: s = 0,
                    playOnce: o = !1,
                    persistOnNav: a = !1,
                    params: r = {}
                }) {
                    const c = d(n);
                    if (this._shouldSkipPlayedAnimation(c)) return void this.unhideComponent(n);
                    const l = {
                            name: e,
                            targetId: n,
                            duration: i,
                            delay: s,
                            params: r
                        },
                        m = {
                            name: "BaseClear",
                            targetId: n,
                            duration: 0,
                            delay: 0,
                            params: {
                                props: "clip,clipPath,webkitClipPath,willChange,opacity,transform,transformOrigin",
                                immediateRender: !1
                            }
                        };
                    this.animator.runSequence([{
                        type: "Animation",
                        data: l
                    }, {
                        type: "Animation",
                        data: m
                    }], {
                        callbacks: {
                            onStart: e => {
                                this._addAnimatingClass(n), this.sessionState.running.set(e, {
                                    targetId: n,
                                    action: t
                                })
                            },
                            onComplete: t => {
                                this._removeAnimatingClass(n), this.sessionState.running.delete(t)
                            },
                            onInterrupt: t => {
                                this._removeAnimatingClass(n), this.sessionState.running.delete(t)
                            }
                        }
                    }), this.sessionState.played.set(c, {
                        playOnce: o,
                        persistOnNav: a
                    })
                }
                stopAnimations({
                    skipPersistent: t = !0
                } = {}) {
                    this.sessionState.running.forEach((({
                        targetId: e
                    }, n) => {
                        const i = d(e);
                        t && this.sessionState.played.get(i).persistOnNav || this.animator.kill(n, 1)
                    }))
                }
                getAnimationProperties(t) {
                    return this.animator.getAnimationProperties(t)
                }
                getCompsToHide(t) {
                    return Object.entries(t).reduce(((t, [e, n]) => (n.some((({
                        name: t
                    }) => {
                        const e = this.animator.getAnimationProperties(t);
                        return e && e.hideOnStart
                    })) && t.push({
                        compId: e
                    }), t)), [])
                }
                clearState() {
                    this.sessionState.played.clear(), this.sessionState.running.clear()
                }
            }
            var m = n(33964);

            function p({
                manager: t
            }) {
                const e = "screenIn",
                    n = {};

                function i(n) {
                    const i = n.filter((t => t.visible)).map((t => ({
                        compId: t.id,
                        action: e
                    })));
                    t.trigger(i)
                }

                function s(t, e) {
                    const s = n[e] || function(t, e) {
                        const n = {
                            root: null,
                            rootMargin: "0px",
                            threshold: [e]
                        };
                        return new window.IntersectionObserver((function(e, n) {
                            const i = e.map((t => ({
                                visible: t.isIntersecting,
                                ratio: t.intersectionRatio,
                                rect: t.intersectionRect,
                                id: t.target.id
                            })));
                            e.forEach((t => t.isIntersecting && n.unobserve(t.target))), t(i)
                        }), n)
                    }(i, e);
                    s.observe(t), n[e] || (n[e] = s)
                }
                return {
                    start: function(e, n, i) {
                        const o = window.innerHeight;
                        if (n) {
                            const e = n.offsetHeight > o ? .01 : function(t, e) {
                                return t.getAnimationProperties(e).viewportThreshold
                            }(t, i) || 0;
                            s(n, e)
                        }
                    }
                }
            }
            var u = n(95772);
            const h = (0, r.ic)([(0, r.iE)(i.wx, m.N9), (0, r.iE)(i.a_, m.N9), s.K, o.kb, a.s, (0, r.Q3)(c.s1)], ((t, e, n, i, s, o) => () => {
                    const {
                        compIdToActions: a,
                        compIdToRotations: r
                    } = t;
                    if (n && !(0, u.wN)(i)) return void Object.keys(a).forEach((async t => {
                        await s.waitForComponentToRender(t), l.prototype.unhideComponent(t)
                    }));
                    if (!o) return;
                    const c = o.getInstance().then((t => {
                        const n = e.get() ? .screenInManager ? ? new l(t);
                        n.init(a);
                        const i = p({
                            manager: n
                        });
                        return e.update((t => ({ ...t,
                            screenInManager: n,
                            viewport: i
                        }))), {
                            animations: i,
                            screenInManager: n
                        }
                    }));
                    return async (t, e, i) => {
                        if (!i) return;
                        const {
                            animations: s,
                            screenInManager: o
                        } = await c;
                        if (n) return void o.unhideComponent(t);
                        let d = a[t];
                        if (e !== t) {
                            const t = JSON.parse(JSON.stringify(d));
                            t[0].targetId = e, d = t
                        }
                        o.addDefinition({
                            [e]: d
                        }, i, r[t]), s.start(e, i, d[0].name)
                    }
                })),
                g = (0, r.ic)([(0, r.iE)(i.wx, m.N9), m.Il, a.s], ((t, e, n) => {
                    let i = () => {};
                    return {
                        name: "screenInInit",
                        pageWillMount() {
                            const s = new Set,
                                o = e();
                            if (!o) return;
                            const a = Object.keys(t.compIdToActions || {});
                            i = n.registerToCompLifeCycle(a, m.OW, ((t, e, n) => {
                                s.has(e) ? s.delete(e) : o(t, e, n)
                            }))
                        },
                        pageWillUnmount() {
                            i()
                        }
                    }
                }));
            var f = n(5632);
            const y = t => {
                t(m.Il).to(h), t(f.c.PageWillMountHandler, f.c.PageWillUnmountHandler).to(g)
            }
        }
    }
]);
//# sourceMappingURL=https://static.parastorage.com/services/wix-thunderbolt/dist/group_35.62352032.chunk.min.js.map