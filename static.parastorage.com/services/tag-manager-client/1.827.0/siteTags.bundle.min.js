(() => {
    "use strict";
    const e = "Tag Manager: ",
        t = function() {
            let e = !1;
            try {
                const t = window;
                e = t && t.debug || t.location && (t.location.search || "").toLowerCase().indexOf("debug=") > -1
            } catch (e) {}
            return e
        }();

    function n(n) {
        t && console && console.error(e + " " + n)
    }

    function o(e) {
        let t = e;
        try {
            t = JSON.parse(e)
        } catch (e) {
            n("Parse error in string"), n(e.message)
        }
        return t
    }

    function i(e, t) {
        return e && "true" === e[t]
    }
    const r = "_api/tag-manager/api/v1/tags/",
        a = r + "sites/",
        d = [".wix.com", ".editorx.com"],
        c = "22bef345-3c5b-4c18-b782-74d4085112ff",
        s = "specs.tagManagerRenderTagByPageID",
        u = "specs.tagManager.ReadLoadOnceFromTag";
    let l = [];
    const g = [],
        f = [],
        p = [];
    let m = [],
        w = {};

    function E() {
        return p
    }

    function h() {
        return I(w)
    }

    function y(e) {
        return Object.keys(e).filter((t => !!e[t] && -1 === m.indexOf(t)))
    }

    function b(e) {
        l = e
    }

    function A(e) {
        g.push(e)
    }

    function T(e) {
        f.push(e)
    }

    function I(e) {
        return o(JSON.stringify(e))
    }
    const x = !!document.documentMode;

    function P(e, t, n) {
        let o;
        x ? (o = document.createEvent("CustomEvent"), o.initCustomEvent(e, !0, !0, n)) : o = new CustomEvent(e, {
            detail: n
        }), t && t.dispatchEvent && setTimeout((() => {
            t.dispatchEvent(o)
        }), 0)
    }
    const v = {
        TAG_MANAGER_LOADED: "TagManagerLoaded",
        TAGS_LOADING: "LoadingTags",
        TAG_LOADED: "TagLoaded",
        TAG_LOAD_ERROR: "TagLoadError"
    };

    function O(e, t, o) {
        const i = () => {
            try {
                if ("function" == typeof e) return e(t)
            } catch (e) {
                n(e)
            }
        };
        return !0 === o ? setTimeout(i, 0) : i()
    }

    function N(e, t, n, o) {
        return () => {
            P(e, window, {
                    tagName: t,
                    embed: n
                }), o(n),
                function(e) {
                    l = l.filter((t => t.name !== e))
                }(n.name)
        }
    }

    function L(e, t) {
        let n;
        return e.nodeType === Node.TEXT_NODE ? n = document.createTextNode(e.content) : e.nodeType === Node.COMMENT_NODE ? n = document.createComment(e.content) : (n = document.createElement(e.tag), e && e.attributes instanceof NamedNodeMap ? Array.prototype.forEach.call(e.attributes, (e => {
            C(n, e.name, e.value)
        })) : "object" == typeof e.attributes && Object.keys(e.attributes).forEach((t => {
            void 0 !== typeof e.attributes[t] && C(n, t, e.attributes[t])
        })), "SCRIPT" === e.tag ? function(e, t, n) {
            void 0 === t && (t = "");
            t && (e.src = function(e) {
                const t = new Blob([e], {
                    type: "text/javascript;charset=utf-8"
                });
                return URL.createObjectURL(t)
            }(t));
            e.addEventListener("load", (() => {
                O(n && n.onload, null)
            }), !1), e.addEventListener("error", (() => {
                O(n && n.onerror, null)
            }), !1)
        }(n, e.content, t) : e.children && e.children.length > 0 && e.children.forEach((e => {
            const o = L(e, t);
            n.appendChild(o)
        }))), n
    }

    function C(e, t, n) {
        e.setAttribute(t, n)
    }

    function D(e) {
        const t = [],
            n = document.createElement("DIV");
        return n.innerHTML = e, Array.prototype.forEach.call(n.childNodes, (e => {
            const n = M(e);
            t.push(n)
        })), t
    }

    function M(e) {
        const t = e.nodeType,
            n = e.innerHTML || e.textContent || e.nodeValue,
            o = [];
        return e.hasChildNodes() && Array.prototype.forEach.call(e.childNodes, (e => {
            o.push(M(e))
        })), {
            nodeType: t,
            tag: e.nodeName,
            attributes: e.attributes,
            content: n,
            children: o
        }
    }
    let R = function(e) {
        return e.HEAD = "head", e.BODY_START = "bodyStart", e.BODY_END = "bodyEnd", e
    }({});
    const S = e => !e.id,
        _ = e => {
            var t;
            return !(null != (t = e.tag) && null != (t = t.pages) && t.length)
        },
        G = (e, t) => {
            var n;
            return (null == (n = e.tag) || null == (n = n.pages) ? void 0 : n.includes(t.id || "")) || !1
        };

    function j(e, t) {
        return e.filter((e => function(e, t) {
            return S(t) || _(e) || G(e, t)
        }(e, t)))
    }

    function B(e, t, n) {
        const o = e.filter((e => !e.embeddedNodes)),
            r = i(n, s) ? j(o, t) : o,
            a = r.map((e => e.tag));
        b(a), P(v.TAGS_LOADING, window, a), r.forEach((e => {
            const t = e.tag,
                n = D(t.content),
                o = t.position && t.position !== R.HEAD ? document.body : document.head,
                i = function(e, t, n, o) {
                    const i = [];
                    let r = 0;
                    const a = () => {
                            r -= 1, r >= 0 && O(t.onload, {})
                        },
                        d = () => {
                            r -= 1, r >= 0 && O(t.onerror, {
                                error: !0
                            })
                        },
                        c = n.firstChild;
                    e.forEach((e => {
                        "SCRIPT" === e.tag && (r += 1);
                        const t = L(e, {
                            onload: a,
                            onerror: d
                        });
                        i.push(t), o ? n.insertBefore(t, c) : n.appendChild(t)
                    })), 0 === r && O(t.onload, {}, !0);
                    return i
                }(n, {
                    onload: N(v.TAG_LOADED, t.name, t, A),
                    onerror: N(v.TAG_LOAD_ERROR, t.name, t, T)
                }, o, t.position === R.BODY_START);
            e.embeddedNodes = i
        }))
    }

    function U(e, t, n, o) {
        const i = o && o.headers || {},
            r = o && o.query || {};
        i["content-type"] = i["content-type"] || "application/json";
        const a = new XMLHttpRequest,
            d = o && o.postBody ? "POST" : "GET",
            c = "" + e + function(e) {
                let t = "";
                "object" == typeof e && Object.keys(e).forEach((n => {
                    if (void 0 !== e[n]) {
                        const o = encodeURIComponent(e[n]);
                        t += encodeURIComponent(n) + "=" + o + "&"
                    }
                }));
                return t = t ? t.substr(0, t.length - 1) : "", t ? "?" + t : ""
            }(r);
        a.open(d, c, !0), a.onreadystatechange = () => {
            if (4 === a.readyState) {
                const e = a.status;
                e < 200 || e >= 300 ? O(n, {
                    status: e,
                    responseText: a.responseText
                }) : O(t, a.responseText)
            }
        }, Object.keys(i).forEach((e => {
            void 0 !== i[e] && a.setRequestHeader(e, i[e])
        })), a.send(o && o.postBody || null)
    }

    function H(e, t) {
        void 0 === t && (t = location.search);
        let n = t.split(e + "=")[1];
        return n = n ? decodeURIComponent(n.split("&")[0]) : void 0, n
    }

    function k(e, t) {
        const r = o(e),
            {
                currentPageID: a,
                initConsentPolicyManager: d = !1
            } = t;
        var c, s, l, g;
        if (r.errors && r.errors.length > 0 && n(JSON.stringify(r.errors)), r.config && ((s = r.config.consentPolicy) && "object" == typeof s && (m = [...m, ...y(s)]), d && window.consentPolicyManager && window.consentPolicyManager.init({
                consentPolicy: r.config.consentPolicy
            }), "object" != typeof(c = r.config) || Array.isArray(c) || (w = { ...w,
                ...c
            })), r.tags) {
            l = r.tags, i(null == (g = w) ? void 0 : g.experiments, u) ? l.forEach((e => {
                var t;
                const n = e.loadOnce || (null == (t = e.content) ? void 0 : t.includes('load-once="true"'));
                p.push({
                    tag: { ...e,
                        loadOnce: n
                    },
                    embeddedNodes: null
                })
            })) : l.forEach((e => {
                p.push({
                    tag: e,
                    embeddedNodes: null
                })
            }));
            const e = {
                id: a
            };
            B(E(), e, r.config.experiments)
        }
    }
    const q = () => "partytown" in window;

    function J(e, t, n) {
        return (e && ! function(e) {
            let t = !1;
            return d.forEach((e => {
                t || (t = location.hostname.indexOf(e) > 0)
            })), t || e
        }(!!n) ? e : "") + "/" + a + t
    }

    function Y(e) {
        const {
            metasiteId: t,
            htmlsiteId: o,
            baseUrl: i,
            wixSite: r,
            language: a,
            categories: d
        } = e, s = H("site-override"), u = H("apps-override"), l = J(i, t, r), g = !r && window.consentPolicyManager ? window.consentPolicyManager._getConsentPolicyHeader() : {}, f = function(e) {
            return e.wixEmbedsAPI.getCurrentPageInfo && "function" == typeof e.wixEmbedsAPI.getCurrentPageInfo && e.wixEmbedsAPI.getCurrentPageInfo() || {}
        }(window), p = H("omit"), m = window.wixEmbedsAPI.getAppToken;
        m && (g.authorization = O(m, c)), U(l, (e => {
            k(e, {
                initConsentPolicyManager: !d && !!r,
                currentPageID: f.id
            })
        }), (e => {
            n("Error loading site tags at " + l), n(e.message)
        }), {
            query: {
                wixSite: !!r,
                htmlsiteId: o,
                language: a,
                categories: d,
                omit: p,
                partytown: q(),
                siteOverrideId: s,
                appsOverrideId: u
            },
            headers: g
        })
    }

    function V(e) {
        E().forEach((e => {
            e.tag.loadOnce || (e.embeddedNodes && e.embeddedNodes.forEach((e => {
                O((() => {
                    e.parentNode.removeChild(e)
                }))
            })), e.embeddedNodes = null)
        }));
        B(E(), e, h().experiments)
    }

    function W(e) {
        if (e && e.detail && e.detail.policy) {
            const t = y(e.detail.policy);
            t.length && Y({
                baseUrl: window.wixEmbedsAPI.getExternalBaseUrl(),
                htmlsiteId: window.wixEmbedsAPI.getHtmlSiteId(),
                metasiteId: window.wixEmbedsAPI.getMetaSiteId(),
                wixSite: window.wixEmbedsAPI.isWixSite(),
                language: window.wixEmbedsAPI.getLanguage(),
                categories: t
            })
        }
    }
    const X = {
        getLoadedTags: function() {
            return I(g)
        },
        getLoadingTags: function() {
            return I(l)
        },
        getLoadErrorTags: function() {
            return I(f)
        },
        getConfig: h
    };
    let z = () => {
        const e = window.wixEmbedsAPI;
        Y({
            baseUrl: e.getExternalBaseUrl(),
            htmlsiteId: e.getHtmlSiteId(),
            metasiteId: e.getMetaSiteId(),
            language: e.getLanguage(),
            wixSite: e.isWixSite()
        }), window.wixEmbedsAPI.registerToEvent("pageNavigation", V), document.addEventListener("consentPolicyChanged", W), window.wixTagManager = X, P(v.TAG_MANAGER_LOADED, window, X)
    };
    window.wixEmbedsAPI && "function" == typeof window.wixEmbedsAPI.registerToEvent ? z() : window.addEventListener("wixEmbedsAPIReady", (() => {
        z(), z = function() {}
    }), !1)
})();
//# sourceMappingURL=siteTags.bundle.min.js.map