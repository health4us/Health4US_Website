import {
    parseLeanSchemaRef
} from '..';
export function schemaSerializer(rootSchema, depSchemas, converterSets) {
    if (depSchemas === void 0) {
        depSchemas = {};
    }
    return function serialize(json, converterType) {
        if (json === void 0) {
            json = {};
        }
        return typeof json === 'string' ? json : transformSchema(rootSchema, json);

        function transformSchema(schema, payload) {
            var result = {};
            if ([null, undefined].includes(payload)) {
                return payload;
            }
            Object.entries(payload).forEach(function(_a) {
                var _b, _c, _d;
                var key = _a[0],
                    val = _a[1];
                var renderedSchemaName = schema[key];
                var _e = parseLeanSchemaRef(renderedSchemaName),
                    schemaName = _e.schemaName,
                    schemaType = _e.schemaType;
                var isMap = schemaType === 'Map';
                var isRepeatable = (_d = (_c = (_b = getConverter(schemaName)) === null || _b === void 0 ? void 0 : _b.checkRepetable) === null || _c === void 0 ? void 0 : _c.call(_b, val)) !== null && _d !== void 0 ? _d : Array.isArray(val);
                var parsedValue;
                if (isRepeatable) {
                    parsedValue = val.map(function(v) {
                        return applyField(v, schemaName);
                    });
                } else if (isMap) {
                    parsedValue = applyFieldOnMap(val, schemaName);
                } else {
                    parsedValue = applyField(val, schemaName);
                }
                result[key] = parsedValue;
            });
            return result;
        }

        function applyField(val, schemaOrSerializer) {
            if (!schemaOrSerializer) {
                return val;
            }
            var maybeSchema = depSchemas[schemaOrSerializer];
            var maybeConverter = getConverter(schemaOrSerializer);
            if (maybeConverter) {
                return getConverter(schemaOrSerializer).transform(val);
            } else if (maybeSchema) {
                return transformSchema(maybeSchema, val);
            }
            throw new Error("".concat(schemaOrSerializer, " is neither schema nor serializable type"));
        }

        function getConverter(name) {
            var _a;
            return (_a = converterSets[name]) === null || _a === void 0 ? void 0 : _a[converterType];
        }

        function applyFieldOnMap(val, sanitizedSchemaOrSerializer) {
            return Object.entries(val).reduce(function(acc, _a) {
                var propertyName = _a[0],
                    value = _a[1];
                acc[propertyName] = applyField(value, sanitizedSchemaOrSerializer);
                return acc;
            }, {});
        }
    };
}
//# sourceMappingURL=serializer.js.map