// Flatten a nested object to params object { field: { text: 'foo' } } => { field.text ='foo' }
function flattenParams(data, path) {
    if (path === void 0) {
        path = '';
    }
    var params = {};
    Object.entries(data).forEach(function(_a) {
        var key = _a[0],
            value = _a[1];
        var isObject = typeof value === 'object' && !Array.isArray(value);
        var fieldPath = resolvePath(path, key);
        if (isObject) {
            var serializedObject = flattenParams(value, fieldPath);
            Object.assign(params, serializedObject);
        } else {
            params[fieldPath] = value;
        }
    });
    return params;
}

function resolvePath(path, key) {
    return "".concat(path).concat(path ? '.' : '').concat(key);
}
export function toURLSearchParams(params) {
    var flatten = flattenParams(params);
    return Object.entries(flatten).reduce(function(urlSearchParams, _a) {
        var key = _a[0],
            value = _a[1];
        if (Array.isArray(value)) {
            // inorder to make `foo: [1,2]` turn into `foo=1&foo=2` and not `foo[]=1&foo[]=2`
            value.forEach(function(v) {
                urlSearchParams.append(key, v);
            });
        } else {
            urlSearchParams.append(key, value);
        }
        return urlSearchParams;
    }, new URLSearchParams());
}
//# sourceMappingURL=flatten-params.js.map