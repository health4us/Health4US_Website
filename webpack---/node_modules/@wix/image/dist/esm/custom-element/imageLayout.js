import {
    getScreenHeight,
    setStyle,
    getImageComputedProperties,
    getImageSrc,
} from './utils';
const MOBILE_SAFE_ADDRESSBAR_HEIGHT = 80;

function getHeightOverride(height, mediaHeightOverrideType) {
    // on mobile, documentElement.clientHeight changes when scrolling, because of address bar collapsing.
    // avoiding re-fetching image by returning the same height
    return mediaHeightOverrideType === 'fixed' ||
        mediaHeightOverrideType === 'viewport' ?
        document.documentElement.clientHeight + MOBILE_SAFE_ADDRESSBAR_HEIGHT :
        height;
}

function computeScaleOverrides(imageStyle, targetScale = 1) {
    return targetScale !== 1 ?
        Object.assign(Object.assign({}, imageStyle), {
            width: '100%',
            height: '100%'
        }) : imageStyle;
}
/**
 * compute specific overrides
 */
function computeStyleOverrides(mediaHeightOverrideType, imageStyle, displayMode, targetScale, isResponsive) {
    // image scaling override
    const styleWithScale = computeScaleOverrides(imageStyle, targetScale);
    if (isResponsive) {
        delete styleWithScale.height;
        styleWithScale.width = '100%';
    }
    if (!mediaHeightOverrideType) {
        return styleWithScale;
    }
    // siteBackground on mobile
    const style = Object.assign({}, styleWithScale);
    if (displayMode === 'fill') {
        style.position = 'absolute';
        style.top = '0';
    } else if (displayMode === 'fit') {
        style.height = '100%';
    }
    if (mediaHeightOverrideType === 'fixed') {
        // eliminates white gap when address bar is collapsing
        style['will-change'] = 'transform';
    }
    // force image alignment to include top
    if (style.objectPosition) {
        style.objectPosition = imageStyle.objectPosition.replace(/(center|bottom)$/, 'top');
    }
    return style;
}

function getSourceSetsTargetHeightByEffect(sourceSets, offsetWidth, offsetHeight, screenHeight, services) {
    const sourceSetsTargetHeights = {};
    sourceSets.forEach(({
        mediaQuery,
        scrollEffect
    }) => {
        sourceSetsTargetHeights[mediaQuery] = services.getMediaDimensionsByEffect(scrollEffect, offsetWidth, offsetHeight, screenHeight).height;
    });
    return sourceSetsTargetHeights;
}

function computeSrcSets(measures, imageInfo, envConsts) {
    const {
        sourceSets
    } = imageInfo;
    if (!sourceSets || !sourceSets.length) {
        return;
    }
    const mediaToUri = {};
    sourceSets.forEach(({
        mediaQuery,
        crop,
        focalPoint
    }) => {
        const imageInfoClone = Object.assign(Object.assign({}, imageInfo), {
            targetHeight: (measures.sourceSetsTargetHeights || {})[mediaQuery] || 0,
            imageData: Object.assign(Object.assign({}, imageInfo.imageData), {
                crop,
                focalPoint
            })
        });
        const imageComputedProperties = getImageComputedProperties(imageInfoClone, envConsts, 'img');
        mediaToUri[mediaQuery] = imageComputedProperties.uri || '';
    });
    return mediaToUri;
}

function measure(id, measures, domNodes, {
    containerElm,
    bgEffect = 'none',
    sourceSets,
}, services) {
    var _a, _b;
    const innerImage = domNodes.image;
    const wixImage = domNodes[id];
    const screenHeight = getScreenHeight((_a = services.getScreenHeightOverride) === null || _a === void 0 ? void 0 : _a.call(services));
    // override positioning and scaling of image (SiteBackground mobile override behaviour)
    const mediaHeightOverrideType = containerElm === null || containerElm === void 0 ? void 0 : containerElm.dataset.mediaHeightOverrideType;
    const sourceOfDimensions = (containerElm && bgEffect && bgEffect !== 'none' ? containerElm : wixImage); // default to self
    const {
        width,
        height
    } = ((_b = services.getMediaDimensionsByEffect) === null || _b === void 0 ? void 0 : _b.call(services, bgEffect, sourceOfDimensions.offsetWidth, sourceOfDimensions.offsetHeight, screenHeight)) || {
        width: wixImage.offsetWidth,
        height: wixImage.offsetHeight,
    };
    if (sourceSets) {
        measures.sourceSetsTargetHeights = getSourceSetsTargetHeightByEffect(sourceSets, sourceOfDimensions.offsetWidth, sourceOfDimensions.offsetHeight, screenHeight, services);
    }
    if (!innerImage) {
        return;
    }
    const imgSrc = getImageSrc(innerImage);
    measures.width = width;
    measures.height = getHeightOverride(height, mediaHeightOverrideType);
    measures.screenHeight = screenHeight;
    measures.imgSrc = imgSrc;
    measures.boundingRect = wixImage.getBoundingClientRect();
    measures.mediaHeightOverrideType = mediaHeightOverrideType;
}

function patch(id, measures, domNodes, imageInfo, services, envConsts, loadImage, isResponsive, bgEffect) {
    var _a, _b;
    if (!Object.keys(measures).length) {
        return;
    }
    const {
        imageData
    } = imageInfo;
    const wixImageNode = domNodes[id];
    const image = domNodes.image;
    // no retina scaling for background scroll effects, unless in responsive flow
    if (bgEffect) {
        imageData.devicePixelRatio = isResponsive ? envConsts.devicePixelRatio : 1;
    }
    const targetScale = imageInfo.targetScale || 1;
    const extendedImageInfo = Object.assign(Object.assign(Object.assign({}, imageInfo), (!imageInfo.skipMeasure && {
        targetWidth: (measures.width || 0) * targetScale,
        targetHeight: (measures.height || 0) * targetScale,
    })), {
        displayMode: imageData.displayMode
    });
    const allowWEBPTransform = (_a = services.isExperimentOpen) === null || _a === void 0 ? void 0 : _a.call(services, 'specs.thunderbolt.allowWEBPTransformation');
    const imageComputedProperties = getImageComputedProperties(extendedImageInfo, envConsts, 'img', allowWEBPTransform);
    const computedStyle = ((_b = imageComputedProperties === null || imageComputedProperties === void 0 ? void 0 : imageComputedProperties.css) === null || _b === void 0 ? void 0 : _b.img) || {};
    const imageStyle = computeStyleOverrides(measures.mediaHeightOverrideType, computedStyle, imageData.displayMode, targetScale, isResponsive);
    setStyle(image, imageStyle);
    const src = (imageComputedProperties === null || imageComputedProperties === void 0 ? void 0 : imageComputedProperties.uri) || '';
    wixImageNode.setAttribute('data-src', src);
    const mediaToUri = computeSrcSets(measures, extendedImageInfo, envConsts);
    // clear initial indication that the image src came from ssr render
    wixImageNode.setAttribute('data-has-ssr-src', '');
    if (imageInfo.isLQIP &&
        imageInfo.lqipTransition &&
        !('transitioned' in wixImageNode.dataset)) {
        wixImageNode.dataset.transitioned = '';
        if (image.complete) {
            image.onload = function() {
                image.dataset.loadDone = '';
            };
        } else {
            image.onload = function() {
                if (image.complete) {
                    image.dataset.loadDone = '';
                } else {
                    image.onload = function() {
                        image.dataset.loadDone = '';
                    };
                }
            };
        }
    }
    if (loadImage) {
        image.setAttribute('fetchpriority', 'high');
        image.currentSrc !== src && image.setAttribute('src', src);
        image.srcset && image.srcset !== src && image.setAttribute('srcset', src);
        if (domNodes.picture && extendedImageInfo.sourceSets) {
            Array.from(domNodes.picture.querySelectorAll('source')).forEach((sourceNode) => {
                const mediaQuery = sourceNode.media || '';
                const uri = mediaToUri ? mediaToUri[mediaQuery] : '';
                sourceNode.srcset !== uri && sourceNode.setAttribute('srcset', uri);
            });
        }
    }
}
export default {
    measure,
    patch,
};
//# sourceMappingURL=imageLayout.js.map