'use strict'

const {
    union,
    Result
} = require('@wix/wix-code-adt')
const pull_ = require('lodash/pull')
const merge_ = require('lodash/merge')
const uniqueId_ = require('lodash/uniqueId')
const isFunction_ = require('lodash/isFunction')
const isObject_ = require('lodash/isObject')

const LogEvent = union('LogEvent', {
    BI: ({
        biEvent
    }) => ({
        biEvent
    }),
    Trace: ({
        position,
        payload
    }) => ({
        position,
        payload
    }),
    Info: ({
        message,
        options,
        sessionData
    }) => ({
        message,
        options,
        sessionData
    }),
    Warn: ({
        message,
        options,
        sessionData
    }) => ({
        message,
        options,
        sessionData
    }),
    Error: ({
        error,
        options,
        sessionData
    }) => ({
        error,
        options,
        sessionData
    })
})

const TracePosition = union('TracePosition', {
    None: () => {},
    Start: ({
        traceId
    }) => ({
        traceId
    }),
    End: ({
        traceId,
        durationMs,
        result
    }) => ({
        traceId,
        durationMs,
        result
    })
})

const safeCallback = cb =>
    Result.try(cb).fold(
        e => ({
            sessionDataError: e.stack
        }),
        result => result
    )

const createRegistrar = () => {
    const callbacks = []

    const register = cb => {
        callbacks.push(cb)
        return () => {
            pull_(callbacks, cb)
        }
    }
    const getCallbacks = () => callbacks.slice()

    return {
        register,
        getCallbacks
    }
}

const validateHandlerCreators = handlerCreators => {
    if (!handlerCreators ||
        !Array.isArray(handlerCreators) ||
        handlerCreators.length === 0
    ) {
        return Result.Error(
            '`handlerCreators` is missing or empty, the logger needs at least one handler to work.'
        )
    }

    return handlerCreators.reduce((acc, creator) => {
        return acc.chain(() => {
            return isFunction_(creator) ?
                acc :
                Result.Error('`handlerCreators` must be an array of functions.')
        })
    }, Result.Ok(handlerCreators))
}

const validateHandlers = handlers => {
    return handlers.reduce((acc, handler) => {
        return acc.chain(() => {
            if (!isObject_(handler)) {
                return Result.Error('Handler must be an object.')
            }

            if (!isFunction_(handler.init)) {
                return Result.Error('Handler must have an init function.')
            }

            if (!isFunction_(handler.log)) {
                return Result.Error('Handler must have a log function.')
            }

            return acc
        })
    }, Result.Ok(handlers))
}

const createHandlers = handlerCreators => {
    return validateHandlerCreators(handlerCreators)
        .map(validatedHandlerCreators =>
            validatedHandlerCreators.map(creator => creator())
        )
        .chain(handlers => validateHandlers(handlers))
        .fold(
            errorMessage => {
                throw new Error(errorMessage)
            },
            validatedHandlers => validatedHandlers
        )
}

const invokeHandlers = (handlers, logEvent) => {
    handlers.forEach(handler => handler.log(logEvent))
}

const reportBI = handlers => biEvent => {
    const logEvent = LogEvent.BI({
        biEvent
    })
    invokeHandlers(handlers, logEvent)
}

const reportInfo = (handlers, getSessionData) => (message, options) => {
    const logEvent = LogEvent.Info({
        message,
        options,
        sessionData: getSessionData()
    })
    invokeHandlers(handlers, logEvent)
}

const reportWarn = (handlers, getSessionData) => (message, options) => {
    const logEvent = LogEvent.Warn({
        message,
        options,
        sessionData: getSessionData()
    })
    invokeHandlers(handlers, logEvent)
}

const reportError = (handlers, getSessionData) => (error, options) => {
    const logEvent = LogEvent.Error({
        error,
        options,
        sessionData: getSessionData()
    })
    invokeHandlers(handlers, logEvent)
}

const reportTrace = handlers => payload => {
    const position = TracePosition.None()
    const logEvent = LogEvent.Trace({
        position,
        payload
    })
    invokeHandlers(handlers, logEvent)
}

const traceSync = handlers => (payload, fn) => {
    const ts = Date.now()
    const traceId = uniqueId_()

    invokeHandlers(
        handlers,
        LogEvent.Trace({
            position: TracePosition.Start({
                traceId
            }),
            payload
        })
    )

    try {
        const fnResult = fn()
        const durationMs = Date.now() - ts
        invokeHandlers(
            handlers,
            LogEvent.Trace({
                position: TracePosition.End({
                    traceId,
                    durationMs,
                    result: Result.Ok()
                }),
                payload
            })
        )

        return fnResult
    } catch (error) {
        const durationMs = Date.now() - ts
        invokeHandlers(
            handlers,
            LogEvent.Trace({
                position: TracePosition.End({
                    traceId,
                    durationMs,
                    result: Result.Error(error)
                }),
                payload
            })
        )

        throw error
    }
}

const traceAsync = handlers => (payload, fn) => {
    const ts = Date.now()
    const traceId = uniqueId_()

    invokeHandlers(
        handlers,
        LogEvent.Trace({
            position: TracePosition.Start({
                traceId
            }),
            payload
        })
    )

    return fn()
        .then(promiseResult => {
            const durationMs = Date.now() - ts
            invokeHandlers(
                handlers,
                LogEvent.Trace({
                    position: TracePosition.End({
                        traceId,
                        durationMs,
                        result: Result.Ok()
                    }),
                    payload
                })
            )

            return promiseResult
        })
        .catch(error => {
            const durationMs = Date.now() - ts
            invokeHandlers(
                handlers,
                LogEvent.Trace({
                    position: TracePosition.End({
                        traceId,
                        durationMs,
                        result: Result.Error(error)
                    }),
                    payload
                })
            )

            return Promise.reject(error)
        })
}

const createLogger = ({
    handlerCreators
} = {}) => {
    const handlers = createHandlers(handlerCreators)
    const sessionDataRegistrar = createRegistrar()
    const tracesMap = new Map()

    const getSessionData = () =>
        sessionDataRegistrar
        .getCallbacks()
        .reduce((acc, cb) => merge_(acc, safeCallback(cb)), {})

    const callInit = initParams => {
        handlers.forEach(handler => handler.init(initParams))
    }

    const logger = {
        addSessionData: sessionDataRegistrar.register,
        init: callInit,
        bi: reportBI(handlers),
        info: reportInfo(handlers, getSessionData),
        warn: reportWarn(handlers, getSessionData),
        error: reportError(handlers, getSessionData),
        trace: reportTrace(handlers, tracesMap),
        traceSync: traceSync(handlers, tracesMap),
        traceAsync: traceAsync(handlers, tracesMap)
    }

    return logger
}

module.exports = {
    create: createLogger,
    matchAny: union.any
}