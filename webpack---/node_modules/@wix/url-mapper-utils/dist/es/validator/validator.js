import {
    __read,
    __values
} from "tslib";
import {
    getPathPrefixesValidationMapping,
    getTpaPageIdByUrlMappingKey,
    isSubMappingsKey,
} from '../src';
import {
    noSpacesValidator,
    maxLengthValidator,
    noEmptySegmentValidator,
    containMainVariableValidator,
    onlyOneVariablePerSegmentValidator,
    onlyUniquePublishedUrlValidator,
    onlyUniqueMappingValidator,
    noInvalidCharacters,
    noStartingOrEndingSlash,
    onlyUniqueSavedUrlValidator,
} from './validators';
import {
    UrlValidatorErrors,
} from './types';
export var urlMapperValidatorsFactory = function(params) {
    return new UrlMapperValidators(params);
};
var UrlMapperValidators = /** @class */ (function() {
    function UrlMapperValidators(_a) {
        var urlMappingKey = _a.urlMappingKey,
            pathPrefixes = _a.pathPrefixes,
            urlMappings = _a.urlMappings;
        var _this = this;
        this.initValidators = function() {
            _this.validators = [
                [maxLengthValidator, UrlValidatorErrors.MAX_LENGTH_ERROR],
                [noSpacesValidator, UrlValidatorErrors.NO_SPACES_ERROR],
                [
                    noStartingOrEndingSlash,
                    UrlValidatorErrors.NO_STARTING_OR_ENDING_SLASH_ERROR,
                ],
                [noEmptySegmentValidator, UrlValidatorErrors.NO_EMPTY_SEGMENT_ERROR],
                [noInvalidCharacters, UrlValidatorErrors.NO_INVALID_CHARACTERS_ERROR],
                [
                    containMainVariableValidator,
                    UrlValidatorErrors.CONTAIN_MAIN_VARIABLE_ERROR,
                ],
                [
                    onlyOneVariablePerSegmentValidator,
                    UrlValidatorErrors.ONLY_ONE_VARIABLE_PER_SEGMENT_ERROR,
                ],
                [
                    onlyUniquePublishedUrlValidator,
                    UrlValidatorErrors.ONLY_UNIQUE_PUBLISHED_URL_ERROR,
                ],
                [
                    onlyUniqueSavedUrlValidator,
                    UrlValidatorErrors.ONLY_UNIQUE_SAVED_URL_ERROR,
                ],
                [
                    onlyUniqueMappingValidator,
                    UrlValidatorErrors.ONLY_UNIQUE_MAPPING_ERROR,
                ],
            ];
        };
        this.urlMappings = urlMappings;
        this.pathPrefixes = pathPrefixes;
        this.urlMappingKey = urlMappingKey;
        this.pathPrefix = this.getPathPrefix();
        this.defaultMapping = getPathPrefixesValidationMapping(urlMappingKey, this.pathPrefix);
        this.initValidators();
    }
    UrlMapperValidators.prototype.getPathPrefix = function() {
        var tpaPageId = getTpaPageIdByUrlMappingKey(this.urlMappingKey);
        if (!tpaPageId) {
            if (isSubMappingsKey(this.urlMappingKey)) {
                throw new Error('Url Mapper Validator Error: Validator does not support sub mapping, please use the main url mapping key');
            } else {
                throw new Error("Url Mapper Validator Error: Url mapping key is not supported (".concat(this.urlMappingKey, ")"));
            }
        }
        var pathPrefix = this.pathPrefixes[tpaPageId] || UrlMapperValidators.FALLBACK_PATH_PREFIX;
        return pathPrefix;
    };
    Object.defineProperty(UrlMapperValidators.prototype, "validatorProps", {
        get: function() {
            var _a = this,
                urlMappingKey = _a.urlMappingKey,
                urlMappings = _a.urlMappings,
                pathPrefix = _a.pathPrefix,
                pathPrefixes = _a.pathPrefixes,
                defaultMapping = _a.defaultMapping;
            return {
                urlMappingKey: urlMappingKey,
                urlMappings: urlMappings,
                pathPrefix: pathPrefix,
                pathPrefixes: pathPrefixes,
                defaultMapping: defaultMapping,
            };
        },
        enumerable: false,
        configurable: true
    });
    /**
     *
     * Validate the url mapping
     *
     * @param {String} value value to validate
     * @returns {ValidateReturn} validator object
     */
    UrlMapperValidators.prototype.validate = function(value) {
        var e_1, _a;
        try {
            for (var _b = __values(this.validators), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2),
                    validatorFn = _d[0],
                    error = _d[1];
                var isValid = Boolean(validatorFn(value, this.validatorProps));
                if (!isValid) {
                    return {
                        isValid: isValid,
                        error: error
                    };
                }
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        return {
            isValid: true
        };
    };
    UrlMapperValidators.errorArray = Object.values(UrlValidatorErrors);
    UrlMapperValidators.MAX_URL_MAPPING_LENGTH = 1000;
    UrlMapperValidators.FALLBACK_PATH_PREFIX = 'unknown';
    return UrlMapperValidators;
}());
export {
    UrlMapperValidators
};
//# sourceMappingURL=validator.js.map