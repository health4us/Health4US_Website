import {
    normalizeWixColorFormat
} from '@wix/color-kit';
import {
    generate as generateGradient
} from '@wix/css-gradient-generator';
import {
    getData
} from '@wix/image-kit';
import {
    snakeToCamel,
    omit
} from '@wix/wow-utils';
const TITLE_LENGTH_LIMIT = 100;
const getStaticMediaUrl = () => {
    var _ref, _serviceTopology;
    return (_ref = typeof window !== 'undefined' && ((_serviceTopology = window.serviceTopology) == null ? void 0 : _serviceTopology.staticMediaUrl)) != null ? _ref : '';
};
const getObjectValueByKey = (object, key) => object[key] || object[snakeToCamel(key)];
const url2uri = url => url.replace(/^(.*[/])/, '');

// Variant of santa-core/santa-core-utils/src/coreUtils/core/urlUtils.js
const joinURL = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }
    return args.map(arg => arg.replace(/(^\/)|(\/$)/g, '')).join('/');
};
const parseVideoPosters = fileOutput => fileOutput.image.map(image => url2uri(image.url));
const fixMediaTitleLength = (value, lengthLimit) => {
    const CHARS_TO_ADD = '...';
    const NUM_OF_CHARS_TO_KEEP = 3;
    if (value.length <= lengthLimit) {
        return value;
    }
    const arr = value.split('');
    const numOfCharsToRemove = value.length - lengthLimit + CHARS_TO_ADD.length;
    const isFileTypeSuffix = value.lastIndexOf('.') > value.length - numOfCharsToRemove - NUM_OF_CHARS_TO_KEEP;
    const fileTypeSuffixIndex = isFileTypeSuffix ? value.lastIndexOf('.') : value.length - 1;
    const removeIndex = fileTypeSuffixIndex - numOfCharsToRemove - NUM_OF_CHARS_TO_KEEP;
    arr.splice(removeIndex, numOfCharsToRemove, CHARS_TO_ADD);
    return arr.join('');
};
const parseVideoQualities = fileOutput => {
    var _fileOutput$storyboar;
    const mp4Videos = fileOutput.video.filter(_ref2 => {
        let {
            format
        } = _ref2;
        return format === 'mp4';
    });
    const storyboard = (_fileOutput$storyboar = fileOutput.storyboard) == null ? void 0 : _fileOutput$storyboar.find(_ref3 => {
        let {
            format
        } = _ref3;
        return format === 'mp4';
    });
    const qualities = mp4Videos.map(_ref4 => {
        let {
            width,
            height,
            quality,
            url
        } = _ref4;
        return {
            width,
            height,
            quality,
            url
        };
    });
    if (storyboard) {
        qualities.push({
            quality: 'storyboard',
            width: storyboard.width,
            height: storyboard.height,
            url: storyboard.url
        });
    }
    return qualities;
};
const parseAdaptiveUrls = fileOutput => {
    const adaptiveVideo = getObjectValueByKey(fileOutput, 'adaptive_video');
    return adaptiveVideo.map(item => {
        return {
            format: item.format,
            url: item.url
        };
    });
};
const parseMediaFeatures = fileInfo => {
    var _fileInfo$tags;
    const mediaFeatures = [];
    if ((_fileInfo$tags = fileInfo.tags) != null && _fileInfo$tags.includes('_mp4_alpha')) {
        mediaFeatures.push('alpha');
    }
    return mediaFeatures.length ? mediaFeatures : null;
};
export const alignTypes = {
    CENTER: 'center',
    TOP: 'top',
    TOP_LEFT: 'top_left',
    TOP_RIGHT: 'top_right',
    BOTTOM: 'bottom',
    BOTTOM_LEFT: 'bottom_left',
    BOTTOM_RIGHT: 'bottom_right',
    LEFT: 'left',
    RIGHT: 'right'
};
export const fittingTypes = {
    SCALE_TO_FILL: 'fill',
    SCALE_TO_FIT: 'fit',
    STRETCH: 'stretch',
    ORIGINAL_SIZE: 'original_size',
    TILE: 'tile',
    TILE_HORIZONTAL: 'tile_horizontal',
    TILE_VERTICAL: 'tile_vertical',
    FIT_AND_TILE: 'fit_and_tile',
    LEGACY_STRIP_TILE: 'legacy_strip_tile',
    LEGACY_STRIP_TILE_HORIZONTAL: 'legacy_strip_tile_horizontal',
    LEGACY_STRIP_TILE_VERTICAL: 'legacy_strip_tile_vertical',
    LEGACY_STRIP_SCALE_TO_FILL: 'legacy_strip_fill',
    LEGACY_STRIP_SCALE_TO_FIT: 'legacy_strip_fit',
    LEGACY_STRIP_FIT_AND_TILE: 'legacy_strip_fit_and_tile',
    LEGACY_STRIP_ORIGINAL_SIZE: 'legacy_strip_original_size',
    LEGACY_ORIGINAL_SIZE: 'actual_size',
    LEGACY_FIT_WIDTH: 'fitWidth',
    LEGACY_FIT_HEIGHT: 'fitHeight',
    LEGACY_FULL: 'full',
    LEGACY_BG_FIT_AND_TILE: 'legacy_tile',
    LEGACY_BG_FIT_AND_TILE_HORIZONTAL: 'legacy_tile_horizontal',
    LEGACY_BG_FIT_AND_TILE_VERTICAL: 'legacy_tile_vertical',
    LEGACY_BG_NORMAL: 'legacy_normal'
};
export const MEDIA_TYPES = {
    COLOR: 'Color',
    IMAGE: 'Image',
    VIDEO: 'WixVideo'
};
export const BG_VIDEO_DEFAULTS = {
    opacity: 1,
    autoplay: true,
    loop: true,
    preload: 'auto',
    mute: true
};
export const MEDIA_PLAYER_DEFAULTS = {
    opacity: 1,
    preload: 'auto'
};
export const COLOR_DEFAULTS = {
    mediaRef: null,
    colorOpacity: 1,
    colorOverlay: '',
    colorOverlayOpacity: 0,
    imageOverlay: null,
    filterEffect: null,
    scrollType: 'none',
    alignType: alignTypes.CENTER,
    fittingType: fittingTypes.SCALE_TO_FILL
};
export const FALLBACK_GRADIENT = {
    type: 'GradientLinear',
    angle: 90,
    colorStops: [{
        size: {
            value: 0,
            type: 'percentage'
        },
        color: '#000',
        opacity: 1
    }, {
        size: {
            value: 100,
            type: 'percentage'
        },
        color: '#fff'
    }]
};
export const mediaManagerDefaultPaths = {
    Color: 'public/6ae967c404004038b5e84dd0a6ab2b65/73d89c137a524437880b113939ca24c3',
    // fallback to image
    Image: 'public/6ae967c404004038b5e84dd0a6ab2b65/73d89c137a524437880b113939ca24c3',
    WixVideo: 'public/8e256233-1752-4026-9341-54036e7f875e/d6b6b972-952c-4ab0-b46a-a6c05a0a94a5'
};
export const payloadMediaTypes = {
    IMAGE: 'picture',
    VIDEO: 'video'
};
export const getIdFromUrl = fileUrl => {
    var _result$;
    const result = fileUrl.match(/(?:\/|^)([0-9a-fA-F_]+)(?:\/|$)/) || [];
    return (_result$ = result[1]) != null ? _result$ : '';
};
export const parseVideoFileInfo = (fileInfo, info) => {
    var _fileOutput$video$0$f, _fileOutput$video$;
    const fileInput = getObjectValueByKey(fileInfo, 'file_input');
    const fileOutput = getObjectValueByKey(fileInfo, 'file_output');
    const videoId = getIdFromUrl(getObjectValueByKey(fileInfo, 'file_name') || getObjectValueByKey(fileInfo, 'file_url'));
    const title = fixMediaTitleLength(fileInfo.title, TITLE_LENGTH_LIMIT);
    const qualities = parseVideoQualities(fileOutput);
    const adaptiveVideo = parseAdaptiveUrls(fileOutput);
    const mediaFeatures = parseMediaFeatures(fileInfo);
    // parse poster - get the first item in data
    const imageData = fileOutput.image[0];
    const posterImageRef = {
        type: 'Image',
        width: imageData.width,
        height: imageData.height,
        uri: url2uri(imageData.url),
        description: info.path ? info.path : undefined
    };
    return {
        type: 'WixVideo',
        title,
        videoId,
        duration: +(fileInput.duration / 1000).toFixed(2),
        posterImageRef,
        generatedPosters: parseVideoPosters(fileOutput),
        qualities,
        adaptiveVideo,
        artist: {
            name: fileInfo.vendor || '',
            id: fileInfo.reference || ''
        },
        hasAudio: getObjectValueByKey(fileOutput.video[0], 'audio_bitrate') !== -1,
        fps: ((_fileOutput$video$0$f = (_fileOutput$video$ = fileOutput.video[0]) == null ? void 0 : _fileOutput$video$.fps) != null ? _fileOutput$video$0$f : '').toString(),
        mediaFeatures: mediaFeatures || []
    };
};
export const getVideoBackgroundObject = (fileInfo, info) => {
    const mediaObject = parseVideoFileInfo(fileInfo, info);
    return {
        ...BG_VIDEO_DEFAULTS,
        ...mediaObject
    };
};
export function getMediaPlayerVideoObject(fileInfo, info) {
    const mediaObject = parseVideoFileInfo(fileInfo, info);
    return {
        ...mediaObject,
        ...MEDIA_PLAYER_DEFAULTS
    };
}
export function getVideoPosterObject(videoId, uri, width, height) {
    return {
        type: 'WixVideo',
        videoId,
        posterImageRef: {
            type: 'Image',
            uri,
            width,
            height
        }
    };
}
export function getImageBackgroundObject(fileInfo, info) {
    var _getObjectValueByKey;
    return {
        type: 'Image',
        uri: getObjectValueByKey(fileInfo, 'file_name'),
        title: fixMediaTitleLength(fileInfo.title, TITLE_LENGTH_LIMIT),
        description: info.path,
        width: fileInfo.width,
        height: fileInfo.height,
        artist: {
            name: fileInfo.vendor || '',
            id: fileInfo.reference || ''
        },
        hasAnimation: !!((_getObjectValueByKey = getObjectValueByKey(fileInfo, 'file_input')) != null && _getObjectValueByKey.animated)
    };
}
export function getImageBackgroundObjectFromMediaStudioFile(mediaStudioFileInfo) {
    return {
        type: 'Image',
        uri: mediaStudioFileInfo.id,
        title: fixMediaTitleLength(mediaStudioFileInfo.name, TITLE_LENGTH_LIMIT),
        description: 'private',
        // Media Studio always saves to private media
        width: mediaStudioFileInfo.width,
        height: mediaStudioFileInfo.height,
        artist: {
            name: '',
            id: ''
        } // This is information is not available in Media Studio
    };
}
export function isSmallerFromContainer(width, height, containerWidth, containerHeight) {
    return width < containerWidth && height < containerHeight;
}
export function getMediaType(background) {
    var _background$mediaRef$, _background$mediaRef;
    return (_background$mediaRef$ = background == null || (_background$mediaRef = background.mediaRef) == null ? void 0 : _background$mediaRef.type) != null ? _background$mediaRef$ : MEDIA_TYPES.COLOR;
}

/**
 * removes overlayData from BackgroundMedia data
 * MUTATES DATA!
 */
export function clearOverlayData(data) {
    // todo: should be modified if we want to 'support' overlay for Image type and mobile view
    data.ref.colorOverlay = '';
    data.ref.colorOverlayOpacity = 0;
    data.ref.imageOverlay = null;
}

/**
 * return showStoryboard value , defaults to 'time'
 */
export function getStoryboardDisplayValue(videoData, currentValue) {
    if (currentValue && currentValue !== 'videoAndTime') {
        return currentValue;
    }
    const storyboardItem = videoData.qualities.find(_ref5 => {
        let {
            quality
        } = _ref5;
        return quality === 'storyboard';
    });
    if (storyboardItem && currentValue) {
        return 'videoAndTime';
    }
    return 'time';
}
export function getColorValue(colorResolver, color) {
    var _color;
    color = (_color = color) != null ? _color : '';
    return color.match('color') ? colorResolver(color.replace(/[{}]/g, '')) : color;
}
export function getOverlayStyle(data, colorResolver) {
    const color = getColorValue(colorResolver, data.colorOverlay);
    const [r, g, b] = normalizeWixColorFormat(color);
    const opacity = data.colorOverlayOpacity || 0;
    return {
        backgroundImage: data.imageOverlay ? "url(" + getMediaURl(data.imageOverlay.uri) + ")" : null,
        backgroundColor: color ? "rgba(" + r + ", " + g + ", " + b + ", " + opacity + ")" : null
    };
}
export function generateColorLayer(fill, opacity) {
    if (opacity === void 0) {
        opacity = 1;
    }
    const type = fill.type + "Layer";
    return {
        type,
        opacity,
        fill
    };
}
export function getColorOrGradient(data) {
    var _data$colorLayers, _data$color;
    const fill = ((_data$colorLayers = data.colorLayers) == null ? void 0 : _data$colorLayers[0].fill) || ((_data$color = data.color) == null ? void 0 : _data$color.replace(/[{}]/g, ''));
    return typeof fill !== 'string' && (fill == null ? void 0 : fill.type) === 'SolidColor' ? fill.color : fill;
}
export function getResolvedColor(color, colorResolver) {
    if (typeof color === 'string') {
        return colorResolver(color);
    } else if (color != null && color.type) {
        return generateGradient(color, {
            resolveColor: colorResolver
        });
    }
    return color;
}
export function getFirstColorStopColor(value, colorResolver) {
    let color;
    if (typeof value === 'string') {
        color = value;
    } else if ((value == null ? void 0 : value.type) === 'GradientMesh') {
        var _value$gradients;
        color = (_value$gradients = value.gradients) == null ? void 0 : _value$gradients[0].colorStops[0].color;
    } else {
        var _value$colorStops;
        color = value == null || (_value$colorStops = value.colorStops) == null || (_value$colorStops = _value$colorStops[0]) == null ? void 0 : _value$colorStops.color;
    }
    return getResolvedColor(color || '', colorResolver);
}
export function getColorOpacityValue(data) {
    var _ref6, _data$colorLayers$0$o, _data$colorLayers2;
    return (_ref6 = (_data$colorLayers$0$o = (_data$colorLayers2 = data.colorLayers) == null ? void 0 : _data$colorLayers2[0].opacity) != null ? _data$colorLayers$0$o : data.colorOpacity) != null ? _ref6 : 1;
}
export function getNewColorLayers(data, value, opacity) {
    var _opacity, _value2;
    if (value === void 0) {
        value = getColorOrGradient(data);
    }
    let colorLayers;
    opacity = (_opacity = opacity) != null ? _opacity : getColorOpacityValue(data);
    if (typeof value === 'string') {
        var _value;
        colorLayers = [generateColorLayer({
            type: 'SolidColor',
            color: (_value = value) != null ? _value : '#FFFFFF'
        }, opacity)];
    } else if ((_value2 = value) != null && _value2.type) {
        colorLayers = [generateColorLayer(value, opacity)];
    } else if (Array.isArray(value)) {
        colorLayers = [generateColorLayer({
            type: 'GradientMesh',
            gradients: value
        }, opacity)];
    } else {
        // eslint-disable-next-line no-console
        console.error(value, 'is not a type we can set to a colorLayer');
    }
    return colorLayers;
}
const omitIdAndMetaData = obj => omit(obj, ['id', 'metaData']);
export const removeIdsAndMetaDataFromBg = backgroundData => {
    const background = omitIdAndMetaData(backgroundData);
    if (backgroundData.imageOverlay) {
        const imageOverlay = omitIdAndMetaData(backgroundData.imageOverlay);
        background.imageOverlay = imageOverlay;
    }
    if (backgroundData.mediaRef) {
        const mediaRef = omitIdAndMetaData(backgroundData.mediaRef);
        if (backgroundData.mediaRef.posterImageRef) {
            const posterImageRef = omitIdAndMetaData(backgroundData.mediaRef.posterImageRef);
            mediaRef.posterImageRef = posterImageRef;
        }
        background.mediaRef = mediaRef;
    }
    return background;
};
export function getImageDisplayData(_ref7) {
    let {
        fittingType,
        alignType,
        imageUri,
        srcImageWidth,
        srcImageHeight,
        containerWidth,
        containerHeight,
        quality = 85,
        pixelAspectRatio = window.devicePixelRatio,
        htmlTag = 'bg'
    } = _ref7;
    const src = {
        id: imageUri,
        width: srcImageWidth,
        height: srcImageHeight
    };
    const target = {
        width: containerWidth,
        height: containerHeight,
        alignment: alignType,
        htmlTag,
        pixelAspectRatio
    };
    return getData(fittingType, src, target, {
        quality
    });
}
export function getMediaURl(mediaUri, staticMediaUrlOverride) {
    return "" + joinURL(staticMediaUrlOverride != null ? staticMediaUrlOverride : getStaticMediaUrl(), mediaUri);
}

// BI issues - Todo: revisit !

// function cleanIrrelevantBiParams(obj: Record<string, any>) {
//   delete obj.metaData;
//   delete obj.charas;
// }

// function areObjectsEqual(obj1: Record<string, any>, obj2: Record<string, any>) {
//   const keys1 = Object.keys(obj1);
//   const keys2 = Object.keys(obj2);
//   if (keys1.length !== keys2.length) {
//     return false;
//   }
//   for (const key of keys1) {
//     const val1 = obj1[key];
//     const val2 = obj2[key];
//     if (Array.isArray(val1) && Array.isArray(val2)) {
//       if (!areArraysEqual(val1, val2)) {
//         return false;
//       }
//     } else if (typeof val1 === 'object' && typeof val2 === 'object') {
//       if (!areObjectsEqual(val1, val2)) {
//         return false;
//       }
//     } else if (val1 !== val2) {
//       return false;
//     }
//   }
//   return true;
// }

// function areArraysEqual(
//   arr1: Record<string, any>[],
//   arr2: Record<string, any>[],
// ) {
//   if (arr1.length !== arr2.length) {
//     return false;
//   }
//   for (let i = 0; i < arr1.length; i++) {
//     const val1 = arr1[i];
//     const val2 = arr2[i];
//     if (typeof val1 === 'object' && typeof val2 === 'object') {
//       if (!areObjectsEqual(val1, val2)) {
//         return false;
//       }
//     } else if (val1 !== val2) {
//       return false;
//     }
//   }
//   return true;
// }

// export function getDifferences(
//   obj1: Record<string, any>,
//   obj2: Record<string, any>,
// ) {
//   cleanIrrelevantBiParams(obj1);
//   cleanIrrelevantBiParams(obj2);
//   const diffs: Record<string, any> = {};
//   const keys1 = Object.keys(obj1);
//   const keys2 = Object.keys(obj2);
//   const keys = [...keys1, ...keys2];
//   for (const key of keys) {
//     const val1 = obj1[key];
//     const val2 = obj2[key];
//     if (Array.isArray(val1) && Array.isArray(val2)) {
//       if (!areArraysEqual(val1, val2)) {
//         diffs[key] = [...val2];
//       }
//     } else if (typeof val1 === 'object' && typeof val2 === 'object') {
//       if (!areObjectsEqual(val1, val2)) {
//         const innerDiffs = getDifferences(val1, val2);
//         Object.keys(innerDiffs).forEach((innerKey) => {
//           diffs[innerKey] = innerDiffs[innerKey];
//         });
//       }
//     } else if (val1 !== val2) {
//       diffs[key] = val2;
//     }
//   }
//   return diffs;
// }

// export function getMediaBiParams(data: BackgroundData) {
//   const media = data.mediaRef;

//   const colorLayer = {
//     color: data.color,
//     opacity: data.colorOpacity !== undefined ? data.colorOpacity : 1,
//   };
//   if (data.colorLayers) {
//     const fillColor = data.colorLayers?.[0].fill;
//     colorLayer.opacity = data.colorLayers?.[0].opacity || 1;
//     if (fillColor.type === 'SolidColor' && fillColor.color) {
//       colorLayer.color = fillColor.color;
//     } else {
//       colorLayer.color = JSON.stringify(fillColor);
//     }
//   }

//   return {
//     bg_media_type: media?.type || 'color',
//     bg_media_name: media?.uri || (media as VideoData)?.videoId || '',
//     bg_vendor_name: media?.artist?.name,
//     bg_vendor_media_id: media?.artist?.id,
//     bg_color: colorLayer.color,
//     bg_color_opacity: colorLayer.opacity,
//     bg_fitting: data.fittingType || fittingTypes.SCALE_TO_FILL,
//     bg_positioning: data.alignType || alignTypes.CENTER,
//     bg_image_opacity:
//       media?.type === 'Image' ? Math.floor((media.opacity ?? 1) * 100) : 100,
//     bg_overlay_color: data.colorOverlay || '',
//     bg_overlay_color_opacity: Math.floor((data.colorOverlayOpacity || 1) * 100),
//     bg_overlay_blend: data.overlayBlending?.blendMode || '',
//     bg_video_overlay_pattern: data?.imageOverlay?.uri || 'none',
//     bg_video_opacity:
//       media?.type === 'WixVideo' ? Math.floor((media.opacity ?? 1) * 100) : 100,
//     bg_video_loop: (media as VideoData)?.loop?.toString() || 'true',
//     bg_video_speed: (media as VideoData)?.playbackSpeed || 1,
//   };
// }
//# sourceMappingURL=backgroundUtils.js.map