import {
    isBrowser,
    LOCAL_DEV_HOSTS
} from '../utils';
import {
    loadAssets
} from './loadAssets';
import {
    createPromiseGuard,
    getScriptTag,
    withRetry
} from './utils';
const RETRY_TIMES = 3;
/**
 * we need to pass hot bundle id for AMD cases
 * otherwise hot bundle will never be executed
 */
const HOT_BUNDLE_ID = 'hot';
async function getAmdRuntime() {
    const code = `
const shouldUseDefaultExportList = new Set(["create-react-class", "lodash"]);
const executeDefineCb = (arg1, arg2, arg3) => {
    var isNamedRegister = typeof arg1 === 'string';
    var name = isNamedRegister ? arg1 : null;
    var depArg = isNamedRegister ? arg2 : arg1;
    var execArg = isNamedRegister ? arg3 : arg2;

    // The System.register(deps, exec) arguments
    var deps, exec;

    // define([], function () {})
    if (Array.isArray(depArg)) {
        deps = depArg;
        exec = execArg;
    }
    // define({})
    else if (typeof depArg === 'object') {
        deps = [];
        exec = function () { return depArg };
    }
    // define(function () {})
    else if (typeof depArg === 'function') {
        deps = requireExportsModule;
        exec = depArg;
    } else {
        throw Error(process.env.SYSTEM_PRODUCTION ? errMsg(9) : errMsg(9, 'Invalid call to AMD define()'));
    }

    const loadModule = async (modName) => {
      const mod = await import(modName);
      if (shouldUseDefaultExportList.has(modName)) {
        return mod.default;
      }
      return mod;
    }
    return Promise.all(deps.map(loadModule)).then(
        (depsExports) => {
            return exec(...depsExports);
        },
    );
};

export default () => {
    let exportsPromise;
    const getExports = () => exportsPromise;
    const define = (arg1, arg2, arg3) => {
        exportsPromise = executeDefineCb(arg1, arg2, arg3);
    }
    define.amd = true;
    return { define, getExports };
};
`;
    const blob = new Blob([code], {
        type: 'text/javascript'
    });
    return URL.createObjectURL(blob);
}
const _fetcher = async (url) => {
    const response = await fetch(url);
    return response.text();
};
const once = (fn) => {
    let hasRes = false;
    let res;
    return ((...args) => {
        if (!hasRes) {
            hasRes = true;
            res = fn(...args);
        }
        return res;
    });
};
const _fetchEnvironment = async (environment, loadResource) => {
    const load = ({
        url
    }) => {
        if (!url) {
            return;
        }
        const element = getScriptTag(url);
        if (element) {
            return Promise.resolve();
        }
        return loadResource(url);
    };
    return Promise.all([
        load({
            url: environment.runtime
        }),
        isBrowser() ? load({
            id: HOT_BUNDLE_ID,
            url: environment.hot
        }) : null,
    ]);
};
export function createEsmResourceLoader({
    fetcher = _fetcher,
}) {
    const amdRuntimeUrl = getAmdRuntime();
    const loadScript = async (url) => {
        const code = await fetcher(url);
        const resCode = `import __getDefine__ from '${await amdRuntimeUrl}';const {define, getExports} = __getDefine__();${code}
export default getExports();
`;
        const blob = new Blob([resCode], {
            type: 'text/javascript'
        });
        const resourceUrl = URL.createObjectURL(blob);
        const exp = await (typeof importShim !== 'undefined' ?
            importShim(resourceUrl) :
            import ( /* webpackIgnore: true */ resourceUrl));
        URL.revokeObjectURL(resourceUrl);
        const res = await exp.default;
        return res;
    };
    const loadScriptWithRetry = (url) => withRetry({
        times: RETRY_TIMES,
        task: async () => loadScript(url),
    });
    return {
        async fetch({
            url
        }) {
            return fetcher(url);
        },
        async fetchLibraryManifest({
            url
        }) {
            const response = await fetcher(url);
            return JSON.parse(response);
        },
        createBundleLoader({
            environment
        }) {
            const guard = createPromiseGuard();
            const fetchEnvironment = once(_fetchEnvironment);
            const loadResource = ({
                url
            }) => guard(url, {
                persistent: !LOCAL_DEV_HOSTS.some(host => url.startsWith(host)),
                factory: async () => {
                    if (environment) {
                        await fetchEnvironment(environment, loadScriptWithRetry);
                    }
                    return loadScriptWithRetry(url);
                },
            });
            return async ({
                url,
                id,
                assets = []
            }) => {
                /**
                 * `loadingAssetsPromise` â€“ not sure we should wait until CSS is loaded,
                 * since it may cause waterfall
                 */
                if (assets) {
                    await loadAssets(assets.filter(a => !!a));
                }
                if (url) {
                    return loadResource({
                        url,
                        id
                    });
                }
            };
        },
    };
}
//# sourceMappingURL=createEsmResourceLoader.js.map