import {
    isBrowser,
    isServer,
    isWorker,
    LOCAL_DEV_HOSTS
} from '../utils';
import {
    evaluateBundle,
    getModel,
    getModelFromContext,
    isOriginalRequireFunctionAvailable,
} from './evaluateBundle';
import {
    loadAssets
} from './loadAssets';
import {
    createPromiseGuard,
    getScriptTag,
    withRetry
} from './utils';
const RETRY_TIMES = 3;
/**
 * we need to pass hot bundle id for AMD cases
 * otherwise hot bundle will never be executed
 */
const HOT_BUNDLE_ID = 'hot';
const _fetcher = async (url) => {
    const response = await fetch(url);
    return response.text();
};
export function createResourceLoader({
    options,
    globals,
    fetcher = _fetcher,
    isExperimentOpen,
}) {
    const contexts = {};
    const loadResource = ({
        id,
        url
    }) => withRetry({
        times: RETRY_TIMES,
        task: async () => {
            if (options && options.useScriptsInsteadOfEval && isBrowser()) {
                const script = document.createElement('script');
                script.src = url;
                try {
                    const pending = new Promise((resolve, reject) => {
                        script.addEventListener('load', () => resolve());
                        script.addEventListener('error', err => reject(err ? .message));
                    });
                    document.head.appendChild(script);
                    await pending;
                } catch (e) {
                    script.remove();
                    throw e;
                }
            } else {
                const bundle = await fetcher(url);
                evaluateBundle(bundle, {
                    id,
                    globals,
                    contexts,
                    useExperimentalEval: options && options.useExperimentalEval,
                });
            }
        },
    });
    const getModelByBundleID = (id) => {
        if (isServer() && isOriginalRequireFunctionAvailable(isExperimentOpen)) {
            return getModelFromContext(id, contexts[id]);
        } else {
            return getModel(id, isExperimentOpen);
        }
    };
    return {
        async fetch({
            url
        }) {
            return fetcher(url);
        },
        async fetchLibraryManifest({
            url
        }) {
            const response = await fetcher(url);
            return JSON.parse(response);
        },
        createBundleLoader({
            environment
        }) {
            const guard = createPromiseGuard();
            let pendingEnvironmentPromise = null;
            const fetchEnvironment = async () => {
                if (pendingEnvironmentPromise) {
                    return pendingEnvironmentPromise;
                }
                const load = ({
                    id,
                    url
                }) => {
                    if (!url) {
                        return;
                    }
                    const element = getScriptTag(url);
                    if (element) {
                        return Promise.resolve();
                    }
                    return loadResource({
                        id,
                        url,
                    });
                };
                pendingEnvironmentPromise = Promise.all([
                    load({
                        url: environment.runtime
                    }),
                    isBrowser() ?
                    load({
                        id: HOT_BUNDLE_ID,
                        url: environment.hot
                    }) :
                    null,
                ]).then(() =>
                    /**
                     * Trigger hot bundle for requirejs env.
                     * otherwise – hot bundle will be loaded but never initialized
                     **/
                    getModelByBundleID(HOT_BUNDLE_ID));
                return pendingEnvironmentPromise;
            };
            return async ({
                url,
                id,
                assets = []
            }) => {
                /**
                 * `loadingAssetsPromise` – not sure we should wait until CSS is loaded,
                 * since it may cause waterfall
                 */
                if (assets) {
                    await loadAssets(assets.filter(a => !!a));
                }
                if (id && (isBrowser() || isWorker())) {
                    const model = await getModel(id, isExperimentOpen);
                    if (model) {
                        return model;
                    }
                }
                await (url ?
                    guard(url, {
                        persistent: !LOCAL_DEV_HOSTS.some(host => url.startsWith(host)),
                        factory: async () => {
                            if (environment) {
                                await fetchEnvironment();
                            }
                            return loadResource({
                                id,
                                url,
                            });
                        },
                    }) :
                    null);
                if (!id) {
                    return null;
                }
                return getModelByBundleID(id);
            };
        },
    };
}
//# sourceMappingURL=createResourceLoader.js.map