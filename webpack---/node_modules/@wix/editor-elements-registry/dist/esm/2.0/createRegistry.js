import {
    getManifestName,
    withProdNamespace,
} from '@wix/editor-elements-conventions';
import {
    createResourceLoader
} from './loaders/createResourceLoader';
import {
    createManifestAPI
} from './manifest/createManifestAPI';
import {
    createLazyComponentLoaders,
    createEagerComponentLoaders,
    getComponentAssets,
} from './loaders/createComponentLoaders';
import {
    loadExternalRegistry,
    EXTERNAL_REGISTRY_OVERRIDE_NAMESPACE,
} from './loaders/loadExternalRegistry';
import {
    validateLibraryURL
} from './toolbox/validateLibraryURL';
import {
    flat
} from './utils';
import {
    createEsmResourceLoader
} from './loaders/createEsmResourceLoader';
import SentryReporter from './sentry';
import {
    initializeWorkaroundForRequire
} from './loaders/evaluateBundle';
export function withDefaultOptions(options) {
    return {
        dev: false,
        useScriptsInsteadOfEval: false,
        usePartialManifests: false,
        useExperimentalEval: false,
        useLazyLoadersInit: false,
        useEsmLoader: false,
        ...options,
    };
}
export const isLibraryTopology = (library) => {
    return library.hasOwnProperty('namespace') && library.hasOwnProperty('url');
};
export async function loadContext({
    host,
    libraries,
    resourceLoader,
    options,
}) {
    const urls = [];
    const manifests = [];
    libraries.forEach((library, index) => {
        if (isLibraryTopology(library)) {
            const manifestName = getManifestName({
                namespace: library.namespace,
                host,
                isDev: false,
            });
            const url = `${library.url}/${manifestName}`;
            urls.push({
                url,
                order: index
            });
        } else {
            manifests.push({
                manifest: createManifestAPI(library),
                order: index,
            });
        }
    });
    const loadManifests = () => {
        return Promise.all(urls.map(async ({
            url,
            order
        }) => {
            const manifest = await resourceLoader.fetchLibraryManifest({
                url,
            });
            return {
                order,
                manifest: createManifestAPI(manifest),
            };
        }));
    };
    if (!options.usePartialManifests) {
        manifests.push(...(await loadManifests()));
    }
    return {
        manifests,
        urls: urls.map(({
            url
        }) => url),
        loadManifests: options.usePartialManifests ? loadManifests : null,
    };
}

function splitLibraries(libraries) {
    return libraries.reduce((acc, lib) => {
        if (isLibraryTopology(lib) &&
            lib.namespace === EXTERNAL_REGISTRY_OVERRIDE_NAMESPACE) {
            acc.registryOverrideLibrary = lib;
        } else {
            acc.libraries.push(lib);
        }
        return acc;
    }, {
        libraries: [],
        registryOverrideLibrary: null,
    });
}

function filterUntrustedURLs(libraries) {
    return libraries.filter(library => {
        if (isLibraryTopology(library)) {
            return validateLibraryURL(library.url);
        } else {
            return validateLibraryURL(library.baseURL);
        }
    });
}
const createRunAndReport = (captureException, host) => {
    return {
        sync: (method, fnNames) => {
            try {
                const fnResult = method();
                return fnResult;
            } catch (e) {
                captureException(e, {
                    captureContext: {
                        tags: {
                            host,
                            ...fnNames
                        }
                    },
                });
                throw e;
            }
        },
        async: async (asyncMethod, fnNames) => {
            try {
                const fnResult = await asyncMethod();
                return fnResult;
            } catch (e) {
                captureException(e, {
                    captureContext: {
                        tags: {
                            host,
                            ...fnNames
                        }
                    },
                });
                throw e;
            }
        },
    };
};
export function createRegistry({
    host
}) {
    return async ({
        getSentryClient,
        isExperimentOpen,
        ...params
    }) => {
        initializeWorkaroundForRequire(isExperimentOpen);
        let sentryReporter;
        const captureException = (exception, hint) => {
            try {
                sentryReporter =
                    sentryReporter ? ? new SentryReporter(host, getSentryClient);
                return sentryReporter.captureException(exception, hint);
            } catch (error) {
                console.log('Failed to initialize sentry with error:', error);
            }
            return;
        };
        const runAndReport = createRunAndReport(captureException, host);
        const options = withDefaultOptions(params.options || {});
        const resourceLoaderFactory = options.useEsmLoader ?
            createEsmResourceLoader :
            createResourceLoader;
        const resourceLoader = runAndReport.sync(() => resourceLoaderFactory({
            options,
            fetcher: params.fetcher,
            globals: params.globals,
            isExperimentOpen,
        }), {
            methodName: 'resourceLoaderFactory'
        });
        const {
            libraries,
            registryOverrideLibrary
        } = splitLibraries(filterUntrustedURLs(params.libraries));
        if (registryOverrideLibrary) {
            const registry = await runAndReport.async(() => loadExternalRegistry({
                resourceLoader,
                host,
                url: registryOverrideLibrary.url,
            }), {
                methodName: 'loadExternalRegistry'
            });
            return registry({ ...params,
                libraries
            });
        }
        const context = await runAndReport.async(async () => loadContext({
            host,
            libraries,
            resourceLoader,
            options,
        }), {
            methodName: 'loadContext'
        });
        let loaders = {};
        const librariesComponents = {};
        async function createComponentLoaders(manifests) {
            const tasks = manifests.map(async ({
                order,
                manifest
            }) => {
                const loadBundle = resourceLoader.createBundleLoader({
                    environment: manifest.getEnvironment(),
                });
                // without *.local
                const namespace = withProdNamespace(manifest.getNamespace());
                const mode = (params.modes && params.modes[namespace]) || params.mode || 'lazy';
                librariesComponents[order] =
                    mode === 'lazy' ?
                    await runAndReport.async(async () => createLazyComponentLoaders({
                        manifest,
                        loadBundle,
                    }), {
                        methodName: 'createLazyComponentLoaders'
                    }) :
                    await runAndReport.async(async () => createEagerComponentLoaders({
                        manifest,
                        loadBundle,
                    }), {
                        methodName: 'createEagerComponentLoaders'
                    });
            });
            await Promise.all(tasks);
            loaders = {};
            Object.keys(librariesComponents)
                .map(v => parseInt(v, 10))
                .sort()
                .forEach(index => {
                    Object.assign(loaders, librariesComponents[index]);
                });
        }
        if (!options.useLazyLoadersInit) {
            await runAndReport.async(async () => createComponentLoaders(context.manifests), {
                methodName: 'createComponentLoaders'
            });
        }
        const loadComponents = async (componentNames) => {
            const pending = componentNames.map(async (componentName) => {
                return runAndReport.async(async () => ({
                    componentName,
                    model: await loaders[componentName](),
                }), {
                    methodName: 'loadComponents'
                });
            });
            const models = await Promise.all(pending);
            return models.reduce((acc, {
                model,
                componentName
            }) => {
                acc[componentName] = model;
                return acc;
            }, {});
        };
        let isContextFulfilled = false;
        let areComponentsLoadersCreated = !options.useLazyLoadersInit;
        const pendingPromises = {};
        return {
            getComponentsLoaders() {
                return loaders;
            },
            getManifestURLs() {
                return [...context.urls];
            },
            getHostBundleAssets() {
                return flat(context.manifests.map(({
                    manifest
                }) => {
                    const model = runAndReport.sync(() => manifest.getHostBundleModel(), {
                        methodName: 'manifest.getHostBundleModel',
                        apiFunctionName: 'getHostBundleAssets',
                    });
                    return runAndReport.sync(() => getComponentAssets({
                        resource: model
                    }), {
                        methodName: 'getComponentAssets',
                        apiFunctionName: 'getHostBundleAssets',
                    });
                }));
            },
            async loadComponents(componentNames) {
                return runAndReport.sync(async () => loadComponents(componentNames), {
                    methodName: 'loadComponents',
                    apiFunctionName: 'loadComponents',
                });
            },
            loadAllComponents() {
                const componentNames = Object.keys(loaders);
                return runAndReport.sync(async () => loadComponents(componentNames), {
                    methodName: 'loadComponents',
                    apiFunctionName: 'loadAllComponents',
                });
            },
            getLibrariesAssets() {
                return flat(context.manifests.map(({
                    manifest
                }) => runAndReport.sync(() => manifest.getLibraryAssets(), {
                    methodName: 'manifest.getLibraryAssets',
                    apiFunctionName: 'getLibrariesAssets',
                })));
            },
            getRuntime() {
                const _libraries = [
                    ...context.manifests.map(({
                        manifest
                    }) => runAndReport.sync(() => manifest.getManifest(), {
                        methodName: 'manifest.getManifest',
                        apiFunctionName: 'getRuntime',
                    })),
                ];
                if (registryOverrideLibrary) {
                    _libraries.push(registryOverrideLibrary);
                }
                return {
                    libraries: _libraries,
                };
            },
            async ensureComponentLoadersAreCreated() {
                if (!areComponentsLoadersCreated) {
                    if (!pendingPromises.componentsLoaders) {
                        pendingPromises.componentsLoaders = runAndReport.sync(() => createComponentLoaders(context.manifests), {
                            methodName: 'createComponentLoaders',
                            apiFunctionName: 'ensureComponentLoadersAreCreated',
                        });
                    }
                    await pendingPromises.componentsLoaders;
                    areComponentsLoadersCreated = true;
                    pendingPromises.componentsLoaders = null;
                }
            },
            async ensureManifestsAreLoaded() {
                if (!isContextFulfilled && context.loadManifests) {
                    if (!pendingPromises.librariesManifests) {
                        pendingPromises.librariesManifests = new Promise(async (resolve) => {
                            const manifests = await runAndReport.async(async () => context.loadManifests(), {
                                methodName: 'context.loadManifests',
                                apiFunctionName: 'ensureManifestsAreLoaded',
                            });
                            await runAndReport.async(() => createComponentLoaders(manifests), {
                                methodName: 'createComponentLoaders',
                                apiFunctionName: 'ensureManifestsAreLoaded',
                            });
                            resolve();
                        });
                    }
                    await pendingPromises.librariesManifests;
                    isContextFulfilled = true;
                    pendingPromises.librariesManifests = null;
                }
            },
        };
    };
}
//# sourceMappingURL=createRegistry.js.map