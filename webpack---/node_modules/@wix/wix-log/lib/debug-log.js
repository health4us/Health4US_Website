const debug = require('@wix/debug-no-namespace');
const resolve = require('./name-resolver');
const enableNamespace = require('./enable-namespace');
const assert = require('assert');
const util = require('util');
const LRU = require('lru-cache');
const MAX_CACHE_SIZE = 10000;
const cachedNamespaces = new LRU(MAX_CACHE_SIZE);
const {
    sanitize
} = require('@wix/wnp-log-sanitizer');

class DebugLogger {
    constructor(name, requestData = {}, {
        skipEnablingErrors,
        customData
    } = {}) {
        assert(name, 'Name must be provided');
        this._requestData = requestData;
        this._customData = customData || {};
        this._name = name;
        const logKeys = resolve(name);

        const errorNamespace = logKeys['error'];
        if (!skipEnablingErrors && process.env.DEBUG_ENV_ONLY !== 'true' && !isNamespaceEnabled(errorNamespace)) {
            // We just cached the "enabled=false". We are going to enable this NS - let's clear the cache
            cachedNamespaces.del(errorNamespace);
            debug.enable(enableNamespace(process.env['DEBUG'], errorNamespace));
        }

        ['info', 'debug', 'error', 'trace', 'warn'].forEach(level => {
            const levelNamespace = logKeys[level];
            this[`_${level}`] = logWith(cachedLogger(levelNamespace), this._requestData, this._customData, levelNamespace, level);
        });
    }

    withRequest(req) {
        return this.withAspects(req.aspects);
    }

    withAspects(aspects) {
        const requestId = get(aspects, 'raw.inbound.x-wix-request-id');
        return new DebugLogger(this._name, {
            ...(requestId ? {
                requestId
            } : {
                requestId: undefined
            }),
            ...this._requestData
        }, {
            skipEnablingErrors: true,
            customData: this._customData
        });
    }

    withData(data) {
        return new DebugLogger(this._name,
            this._requestData, {
                skipEnablingErrors: true,
                customData: { ...this._customData,
                    ...data
                }
            });
    }

    trace(...args) {
        this._trace(args);
    }

    debug(...args) {
        this._debug(args);
    }

    info(...args) {
        this._info(args);
    }

    error(...args) {
        this._error(args);
    }

    warn(...args) {
        this._warn(args);
    }
}

function toKeyValueStringPairs(requestData) {
    return Object.keys(requestData).map(key => `[${key}: ${requestData[key]}]`);
}

function isSanitationEnabled() {
    return process.env['WNP_SANITIZE_LOGS'] === 'true';
}

const LOGGERS = new Map();

function cachedLogger(key) {
    let logger = LOGGERS.get(key);
    if (!logger) {
        logger = debug(key);
        LOGGERS.set(key, logger);
    }
    return logger;
}

function logWith(logger, requestData, customData, namespace) {

    const sanitationEnabled = isSanitationEnabled();
    return argsArray => {
        if (!isNamespaceEnabled(namespace)) {
            return;
        }
        argsArray = argsArray.map(applyErrorStackSuppression);
        const errorDetailsData = getErrorArgAddedData(argsArray);
        const argsWithData = mergeDataItems(argsArray, { ...errorDetailsData,
            ...customData
        });
        const text = util.format.apply(util, toKeyValueStringPairs(requestData).concat(argsWithData).map(el => debug.coerce(el)));
        const textToLog = sanitationEnabled ? sanitize(text) : text;
        logger(textToLog);
    };
}

function getErrorArgAddedData(argsArray) {
    const errorArg = argsArray.find(arg => arg instanceof Error);
    return errorArg && errorArg.details && {
        '_errorDetails': buildErrorDetails(errorArg)
    };
}

function mergeDataItems(argsArray, customData) {
    if (Object.keys(customData).length === 0) {
        return argsArray;
    } else if (argsArray.length > 1 && typeof argsArray[1] === 'object') {
        //merge the logger data into the second arg
        const argsArrayCpy = [...argsArray];
        argsArrayCpy[1] = { ...customData,
            ...argsArrayCpy[1]
        };
        return argsArrayCpy;
    } else {
        return argsArray.concat(customData);
    }
}

function isNamespaceEnabled(namespace) {
    let enabled = cachedNamespaces.get(namespace);
    if (enabled === undefined) {
        enabled = debug.enabled(namespace);
        cachedNamespaces.set(namespace, enabled);
    }
    return enabled;
}

function buildErrorDetails(err) {
    const details = err.details && (typeof err.details === 'object' ? { ...err.details
    } : {
        details: err.details
    });
    const causeDetails = err.cause && {
        _causeDetails: buildErrorDetails(err.cause)
    };
    if (details || causeDetails) {
        return { ...details,
            ...causeDetails
        };
    }
}

function applyErrorStackSuppression(arg) {
    if (arg instanceof Error && arg._doNotLogStackTrace === true) {
        const copy = Object.create(arg);
        copy.stack = arg.toString();
        return copy;
    } else {
        return arg;
    }
}

function get(obj, path) {
    const parts = path.split('.');
    let result = obj;
    while (result !== undefined && parts.length > 0) {
        result = result[parts.shift()];
    }
    return result;
}

module.exports = DebugLogger;