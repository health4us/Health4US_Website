const any = Symbol.for('union-type-any-symbol')

const matchWith = variant => pattern => {
    const patternKeys = Object.keys(pattern)
    for (const key of patternKeys) {
        if (key === variant.name) {
            return pattern[key](variant.payload)
        }
    }

    if (pattern[any]) {
        return pattern[any]()
    }

    throw new Error(
        `Variant "${variant.name}" not covered in pattern with keys [${patternKeys}].\nThis could mean you did not include all variants in your Union's matchWith function.`
    )
}

const variantFactory = (unionName, name, fn, derivedMethods) => {
    const symbol = Symbol(`[${unionName}:${name}]`)
    const variantCtor = (...input) => {
        const payload = fn(...input)
        const variant = {
            matchWith: matchWith({
                name,
                payload
            }),
            toString: () => name,
            [symbol]: true
        }

        Object.keys(derivedMethods).forEach(key => {
            variant[key] = derivedMethods[key](variant)
        })

        return variant
    }

    variantCtor.hasInstance = variantInstance =>
        variantInstance && variantInstance[symbol] === true

    return variantCtor
}

const union = (unionName, variants, derivedMethods = {}) => {
    return Object.keys(variants).reduce((acc, variantName) => {
        acc[variantName] = variantFactory(
            unionName,
            variantName,
            variants[variantName],
            derivedMethods
        )
        return acc
    }, {})
}

union.any = any

module.exports = union