/******/
(function() { // webpackBootstrap
    /******/
    var __webpack_modules__ = ({

        /***/
        231:
            /*!****************************************************************!*\
              !*** ../node_modules/@babel/runtime/helpers/defineProperty.js ***!
              \****************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {

                var toPropertyKey = __webpack_require__( /*! ./toPropertyKey.js */ 40);

                function _defineProperty(obj, key, value) {
                    key = toPropertyKey(key);
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

                /***/
            }),

        /***/
        27:
            /*!*************************************************************!*\
              !*** ../node_modules/@babel/runtime/helpers/toPrimitive.js ***!
              \*************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {

                var _typeof = (__webpack_require__( /*! ./typeof.js */ 501)["default"]);

                function _toPrimitive(input, hint) {
                    if (_typeof(input) !== "object" || input === null) return input;
                    var prim = input[Symbol.toPrimitive];
                    if (prim !== undefined) {
                        var res = prim.call(input, hint || "default");
                        if (_typeof(res) !== "object") return res;
                        throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return (hint === "string" ? String : Number)(input);
                }
                module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

                /***/
            }),

        /***/
        40:
            /*!***************************************************************!*\
              !*** ../node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
              \***************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {

                var _typeof = (__webpack_require__( /*! ./typeof.js */ 501)["default"]);
                var toPrimitive = __webpack_require__( /*! ./toPrimitive.js */ 27);

                function _toPropertyKey(arg) {
                    var key = toPrimitive(arg, "string");
                    return _typeof(key) === "symbol" ? key : String(key);
                }
                module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

                /***/
            }),

        /***/
        501:
            /*!********************************************************!*\
              !*** ../node_modules/@babel/runtime/helpers/typeof.js ***!
              \********************************************************/
            /***/
            (function(module) {

                function _typeof(obj) {
                    "@babel/helpers - typeof";

                    return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                        return typeof obj;
                    } : function(obj) {
                        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                    }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
                }
                module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

                /***/
            })

        /******/
    });
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/
        var cachedModule = __webpack_module_cache__[moduleId];
        /******/
        if (cachedModule !== undefined) {
            /******/
            return cachedModule.exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = __webpack_module_cache__[moduleId] = {
            /******/ // no module.id needed
            /******/ // no module.loaded needed
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /************************************************************************/
    /******/
    /* webpack/runtime/compat get default export */
    /******/
    ! function() {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/
        __webpack_require__.n = function(module) {
            /******/
            var getter = module && module.__esModule ?
                /******/
                function() {
                    return module['default'];
                } :
                /******/
                function() {
                    return module;
                };
            /******/
            __webpack_require__.d(getter, {
                a: getter
            });
            /******/
            return getter;
            /******/
        };
        /******/
    }();
    /******/
    /******/
    /* webpack/runtime/define property getters */
    /******/
    ! function() {
        /******/ // define getter functions for harmony exports
        /******/
        __webpack_require__.d = function(exports, definition) {
            /******/
            for (var key in definition) {
                /******/
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                    /******/
                    Object.defineProperty(exports, key, {
                        enumerable: true,
                        get: definition[key]
                    });
                    /******/
                }
                /******/
            }
            /******/
        };
        /******/
    }();
    /******/
    /******/
    /* webpack/runtime/hasOwnProperty shorthand */
    /******/
    ! function() {
        /******/
        __webpack_require__.o = function(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        /******/
    }();
    /******/
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be in strict mode.
    ! function() {
        "use strict";
        /*!*******************************!*\
          !*** ./client.ts + 8 modules ***!
          \*******************************/

        // UNUSED EXPORTS: ConsentPolicyManager

        // EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/defineProperty.js
        var defineProperty = __webpack_require__(231);
        var defineProperty_default = /*#__PURE__*/ __webpack_require__.n(defineProperty);; // CONCATENATED MODULE: ./js/consts.ts
        const BASE_DOMAINS = ['wix.com', 'editorx.com'];
        const COOKIE_NAME = 'consent-policy';
        const APP_DEF_ID = '22bef345-3c5b-4c18-b782-74d4085112ff';
        const GLOBAL_POLICY_CONTROL_SPEC = 'specs.cookieConsent.PolicyByGlobalPrivacyControl';; // CONCATENATED MODULE: ./js/utils.ts
        function isSameDomain(candidate, hostname) {
            if (candidate === void 0) {
                candidate = '';
            }
            if (hostname === void 0) {
                hostname = '';
            }
            return hostname === candidate || hostname.indexOf("." + candidate) === hostname.replace("." + candidate, '').length;
        }

        function isSameDomainBulk(domainsArray, hostName) {
            return domainsArray.some(domain => isSameDomain(domain, hostName));
        }

        function isWix(hostname) {
            return isSameDomainBulk(BASE_DOMAINS, hostname || location.hostname);
        }

        function readCookieData(cookeName) {
            var _cookieData$pop;
            const regex = "[;\\s ]?" + cookeName + "=([\\S]+(?:;?))";
            const cookieData = document.cookie.match(regex);
            return (cookieData == null ? void 0 : (_cookieData$pop = cookieData.pop()) == null ? void 0 : _cookieData$pop.replace(';', '')) || void 0;
        }

        function enabledExperiment(specName) {
            var _window, _window$wixTagManager, _window2, _window2$wixTagManage, _window2$wixTagManage2, _window2$wixTagManage3;
            if (typeof((_window = window) == null ? void 0 : (_window$wixTagManager = _window.wixTagManager) == null ? void 0 : _window$wixTagManager.getConfig) !== 'function') {
                return false;
            }
            return ((_window2 = window) == null ? void 0 : (_window2$wixTagManage = _window2.wixTagManager) == null ? void 0 : (_window2$wixTagManage2 = _window2$wixTagManage.getConfig()) == null ? void 0 : (_window2$wixTagManage3 = _window2$wixTagManage2.experiments) == null ? void 0 : _window2$wixTagManage3[specName]) === 'true';
        }; // CONCATENATED MODULE: ./js/xhr-driver.ts
        const XSRF_COOKIE_NAME = 'XSRF-TOKEN';
        const XSRF_HEADER_NAME = 'x-xsrf-token';

        function xhrPost(uri, successCallback, errorCallback, postBody, authorization) {
            const xhr = new XMLHttpRequest();
            xhr.open('POST', uri, true);
            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4) {
                    const status = xhr.status;
                    if (status < 200 || status >= 300) {
                        runCallback(errorCallback, status);
                    } else {
                        runCallback(successCallback, xhr.responseText);
                    }
                }
            };
            xhr.setRequestHeader('content-type', 'application/json');
            if (authorization) {
                xhr.setRequestHeader('authorization', authorization);
            }
            const xsrfHeader = readCookieData(XSRF_COOKIE_NAME);
            if (xsrfHeader) {
                xhr.setRequestHeader(XSRF_HEADER_NAME, xsrfHeader);
            }
            xhr.send(postBody || null);
        }

        function runCallback(callback, data) {
            try {
                if (typeof callback === 'function') {
                    callback(data);
                }
            } catch (e) {
                console && console.error(e);
            }
        }; // CONCATENATED MODULE: ./default-policies.ts
        // The default Policy outside the the regulation zone
        const DEFAULT_POLICY = {
            essential: true,
            functional: true,
            analytics: true,
            advertising: true,
            dataToThirdParty: true
        }; // The default Wix domain policy in the EU
        const WIX_EU_POLICY = {
            essential: true,
            functional: true,
            analytics: true,
            advertising: false,
            dataToThirdParty: false
        }; // The gpc / ccpa Wix domain policy in the US
        const WIX_US_GPC_POLICY = {
            essential: true,
            functional: true,
            analytics: false,
            advertising: false,
            dataToThirdParty: false
        };; // CONCATENATED MODULE: ./js/cookie-parser.ts
        const mappingFromCookie = {
            func: 'functional',
            anl: 'analytics',
            adv: 'advertising',
            dt3: 'dataToThirdParty',
            ess: 'essential'
        };

        function getCookieHostParts(hostname) {
            let host = '',
                path = '';
            BASE_DOMAINS.forEach(domain => {
                if (isSameDomain(domain, location.hostname)) {
                    host = "." + domain;
                    path = '/';
                }
            });
            if (!host && !path) {
                host = location.hostname; // Free sites
                const pathParts = hostname.split(location.hostname);
                path = pathParts[1] ? "" + pathParts[1] : '/';
                if (path === '/') {
                    const hostParts = host.split('.'); // Not free sites
                    hostParts.shift();
                    host = "." + hostParts.join('.');
                }
            }
            return {
                host,
                path
            };
        }

        function removeCookie(baseUrl) {
            const policy = getPolicyFromCookie();
            if (policy && !policy.defaultPolicy) {
                const {
                    path,
                    host
                } = getCookieHostParts(baseUrl);
                document.cookie = COOKIE_NAME + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; domain=" + host + "; path=" + path + ";";
                return true;
            }
            return false;
        }

        function getPolicyFromCookie() {
            const cookieData = readCookieData(COOKIE_NAME);
            if (!cookieData || typeof cookieData !== 'string') {
                return false;
            }
            let createdDate;
            const policy = {};
            try {
                const cookieJson = JSON.parse(decodeURIComponent(cookieData));
                Object.keys(mappingFromCookie).forEach(cookiePolicyKey => {
                    if (typeof cookieJson[cookiePolicyKey] === 'number') {
                        const policyKey = mappingFromCookie[cookiePolicyKey];
                        policy[policyKey] = cookieJson[cookiePolicyKey] === 1;
                    }
                });
                createdDate = parseTimeStamp(cookieJson.ts);
                return { // TODO: REMOVE THIS HACK ONE PRODUCT EXPERIMENT ENDS - this is needed to support policy created by the test in the Tag Manager server
                    defaultPolicy: !!cookieJson.temp,
                    policy,
                    createdDate
                };
            } catch (e) {
                return false;
            }
        }

        function parseTimeStamp(ts) {
            let createdDate;
            if (typeof ts === 'number') {
                createdDate = new Date(ts * 1000 * 60);
            }
            return createdDate;
        }

        function getCurrentPolicy(hostname, consentPolicy) {
            const cookiePolicy = getPolicyFromCookie();
            if (cookiePolicy) {
                return cookiePolicy;
            }
            const policy = getDefaultPolicy(hostname, consentPolicy);
            return {
                defaultPolicy: true,
                policy
            };
        }

        function getDefaultPolicy(hostname, consentPolicy) {
            /* 
                flows:
                  1. on consentPolicyManager init for we return the harsh WIX_US_POLICY for wix sites
                  2. once tag manger client inits we return consentPolicy from config which is by geo location
                  3. if gpc option is turned on browser we return WIX_US_POLICY
                on
              */
            if (isInGPCExperiment() && isWix(hostname) && isGPCOn()) {
                return WIX_US_GPC_POLICY;
            }
            return consentPolicy ? clone(consentPolicy) : clone(isWix(hostname) ? WIX_EU_POLICY : DEFAULT_POLICY);
        }

        function isGPCOn() {
            return !!navigator.globalPrivacyControl;
        }

        function isInGPCExperiment() { // currently open only is the US
            return enabledExperiment(GLOBAL_POLICY_CONTROL_SPEC);
        }

        function getConsentPolicyHeader(hostname, consentPolicy) {
            const policy = getCurrentPolicy(hostname, consentPolicy).policy;
            let somethingIsDenied = false;
            const raw = Object.keys(mappingFromCookie).reduce((ret, key) => {
                const value = mappingFromCookie[key]; // @ts-expect-error
                const policyValue = policy[value];
                ret[key] = policyValue ? 1 : 0;
                if (!policyValue) {
                    somethingIsDenied = true;
                }
                return ret;
            }, {});
            return somethingIsDenied ? {
                [COOKIE_NAME]: encodeURIComponent(JSON.stringify(raw))
            } : {};
        }

        function clone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }; // CONCATENATED MODULE: ./js/events.ts
        function publishEvent(eventName, publishingNode, eventData) {
            let customEvent; // @ts-ignore
            const isIE = !!document.documentMode;
            if (isIE) {
                customEvent = document.createEvent('CustomEvent');
                customEvent.initCustomEvent(eventName, true, false, eventData);
            } else {
                customEvent = new CustomEvent(eventName, {
                    detail: eventData,
                    bubbles: true
                });
            }
            publishingNode.forEach(publishNode => {
                if (publishNode && publishNode.dispatchEvent) {
                    publishNode.dispatchEvent(customEvent);
                }
            });
        }
        const EVENT_NAMES = {
            CONSENT_POLICY_MANAGER_READY: 'consentPolicyManagerReady',
            CONSENT_POLICIY_INITIALIZED: 'consentPolicyInitialized',
            CONSENT_POLICY_CHANGED: 'consentPolicyChanged',
            CONSENT_POLICY_UPDATE_REQUESTED: 'consentPolicyUpdateRequested'
        };; // CONCATENATED MODULE: ./js/api-utils.ts
        const APIPath = '/_api/cookie-consent-policy/v1/consent-policies';

        function getXhrDomainPrefix(baseDomain) {
            if (baseDomain === void 0) {
                baseDomain = '';
            }
            let resDomain;
            if (isWix() || !baseDomain) {
                resDomain = '';
            } else {
                resDomain = baseDomain.indexOf('http') === 0 ? baseDomain : "\\\\" + baseDomain;
            }
            return resDomain;
        }

        function getAPIBase(baseUrl) {
            if (baseUrl === void 0) {
                baseUrl = '';
            }
            return "" + getXhrDomainPrefix(baseUrl) + APIPath;
        }; // CONCATENATED MODULE: ./js/consent-policy-manager.ts
        const trimTrailingSlash = str => str.endsWith('/') ? str.slice(0, -1) : str;
        const dispatchPolicyChangedEvent = policy => {
            publishEvent(EVENT_NAMES.CONSENT_POLICY_CHANGED, [window, document], policy);
        };
        class ConsentPolicyManager {
            constructor() {
                defineProperty_default()(this, "config", {
                    baseUrl: ''
                });
                defineProperty_default()(this, "hostname", window.location.hostname);
                defineProperty_default()(this, "initRan", false);
                defineProperty_default()(this, "getValidPolicy", newPolicy => {
                    const resultPolicy = {};
                    const {
                        policy
                    } = this.getCurrentConsentPolicy();
                    if (typeof newPolicy === 'object') {
                        Object.keys(DEFAULT_POLICY).forEach(policyKey => {
                            if (typeof newPolicy[policyKey] === 'boolean') {
                                resultPolicy[policyKey] = newPolicy[policyKey];
                            }
                        });
                    }
                    return { ...policy,
                        ...resultPolicy
                    };
                });
                defineProperty_default()(this, "shouldTriggerConsentPolicyChanged", config => { // TODO: reconsider this code, it checks too many things.
                    // All we really care about is if the current policy (ie CookiePolicy) is different from the one in the config sent to us
                    return config.consentPolicy && this.initRan && this.getCurrentConsentPolicy().defaultPolicy && JSON.stringify(config.consentPolicy) !== JSON.stringify(this.getCurrentConsentPolicy().policy);
                });
                defineProperty_default()(this, "init", options => {
                    const config = typeof options === 'string' ? {
                        baseUrl: options
                    } : {
                        baseUrl: options.baseUrl,
                        consentPolicy: options.consentPolicy
                    } || {};
                    if (config.consentPolicy) {
                        config.consentPolicy = this.getValidPolicy(config.consentPolicy);
                    }
                    let triggerConsentPolicyChanged = this.shouldTriggerConsentPolicyChanged(config);
                    this.initRan = true;
                    this.config = { ...this.config,
                        ...config
                    };
                    this.config.baseUrl = trimTrailingSlash(this.config.baseUrl || ''); //Getting the real state of the policy depdendant on the cookie as well
                    const currentPolicy = this.getCurrentConsentPolicy();
                    publishEvent(EVENT_NAMES.CONSENT_POLICIY_INITIALIZED, [window, document], currentPolicy);
                    if (triggerConsentPolicyChanged) {
                        dispatchPolicyChangedEvent(currentPolicy);
                    }
                });
                defineProperty_default()(this, "setConsentPolicy", (policy, successCallback, errorCallback) => {
                    if (policy === void 0) {
                        const err = 'setConsentPolicy: no policy sent as parameter';
                        errorCallback && errorCallback(err);
                        console.error(err);
                    }
                    const successCB = data => {
                        try {
                            const response = JSON.parse(data);
                            const updatedPolicyDetails = {
                                defaultPolicy: false,
                                policy: response.consent.policy
                            };
                            const ts = response.consent.timestamp;
                            if (ts) {
                                updatedPolicyDetails.createdDate = new Date(ts);
                            }
                            dispatchPolicyChangedEvent(updatedPolicyDetails);
                            successCallback && successCallback(updatedPolicyDetails);
                        } catch (e) {
                            errCB(e);
                        }
                    };
                    const errCB = details => {
                        errorCallback && errorCallback("Failed setting policy. details: " + details);
                    };
                    const policyString = JSON.stringify({
                        policy: { ...this.getValidPolicy(policy),
                            essential: true
                        },
                        location: location.href,
                        ...(this.config.baseUrl ? {
                            baseUrl: this.config.baseUrl
                        } : {})
                    });
                    const embedsAPI = window.wixEmbedsAPI;
                    const authorization = !isWix() && embedsAPI && embedsAPI.getAppToken && embedsAPI.getAppToken(APP_DEF_ID);
                    xhrPost(getAPIBase(this.config.baseUrl), successCB, errCB, policyString, authorization);
                });
                defineProperty_default()(this, "getCurrentConsentPolicy", () => getCurrentPolicy(this.hostname, this.config.consentPolicy));
                defineProperty_default()(this, "_getConsentPolicyHeader", () => getConsentPolicyHeader(this.hostname, this.config.consentPolicy));
            }
            resetPolicy() {
                const cookieRemoved = removeCookie(this.config.baseUrl || '');
                if (cookieRemoved) {
                    setTimeout(() => { //Magic number to allow cookie clearing
                        dispatchPolicyChangedEvent(this.getCurrentConsentPolicy());
                    }, 5);
                }
                return cookieRemoved;
            }
            publishPolicyUpdateRequestedEvent(categories) {
                if (categories === void 0) {
                    categories = [];
                }
                const categoriesArray = Array.isArray(categories) ? categories : [];
                const filteredCategories = categoriesArray.filter((value, index, array) => array.indexOf(value) === index);
                const event = filteredCategories.length === 0 ? {} : {
                    categories: filteredCategories
                };
                publishEvent(EVENT_NAMES.CONSENT_POLICY_UPDATE_REQUESTED, [window, document], event);
            }
        }; // CONCATENATED MODULE: ./client.ts
        if (typeof window !== 'undefined') {
            window.consentPolicyManager = new ConsentPolicyManager();
            publishEvent(EVENT_NAMES.CONSENT_POLICY_MANAGER_READY, [window, document], window.consentPolicyManager);
        }
    }();
    /******/
})();
//# sourceMappingURL=app.bundle.js.map