import {
    definitions
} from '../definitions/definitions';
import {
    toArray
} from '@wix/wow-utils';
import {
    getAnimationMode
} from '../utils/definitionsUtils';
import {
    validateSchema
} from '../utils/validationUtils';
import {
    viewerDefaults
} from '../utils/viewerDefaults';
/**
 * Animations constructor
 */
export class AnimationsKit {
    constructor(engine, frame = window, viewMode = 'desktop', isMotion = false) {
        this.engine = engine;
        this.frame = frame;
        this.engine.adjustLagSmoothing(500, 33);
        const animationMode = getAnimationMode(isMotion ? 'motion' : viewMode);
        this.defs = definitions[animationMode];
        this.validateAnimation = this.validateAnimation.bind(this);
        this.animate = this.animate.bind(this);
        this.transition = this.transition.bind(this);
        this.updateViewMode = this.updateViewMode.bind(this);
        this.sequence = this.sequence.bind(this);
        this.getProperties = this.getProperties.bind(this);
        this.getApiForAnimation = this.getApiForAnimation.bind(this);
        this.addTickerEvent = engine.addTickerEvent;
        this.removeTickerEvent = engine.removeTickerEvent;
        this.kill = engine.kill;
        this.delayedCall = engine.delayedCall;
        this.animateTimeScale = engine.animateTimeScale;
        this.viewerDefaults = viewerDefaults;
    }
    validateAnimation(name, params) {
        const properties = this.getProperties(name);
        if (!properties) {
            console.log(`No such animation "${name}"`);
            return false;
        }
        return validateSchema(properties.schema || {}, params, (errors) => errors.forEach((error) => console.error(error)));
    }
    animate(name, elements, duration, delay = 0, params = {}) {
        if (this.validateAnimation(name, Object.assign({
                duration,
                delay
            }, params))) {
            return this.defs[name].animate(this, toArray(elements), duration, delay, params);
        }
        return this.defs.BaseNone.animate(this, toArray(elements), 0, 0, {});
    }
    transition(name, sourceElements, destinationElements, duration, delay = 0, params = {}) {
        if (this.validateAnimation(name, Object.assign({
                duration,
                delay
            }, params))) {
            return this.defs[name].transition(this, toArray(sourceElements), toArray(destinationElements), duration, delay, params);
        }
        return this.defs.noTransition.transition(this, sourceElements, destinationElements, 0, 0, {});
    }
    updateViewMode(mode, frame = window) {
        const animationMode = getAnimationMode(mode);
        this.defs = definitions[animationMode];
        if (frame) {
            this.frame = frame;
        }
    }
    sequence(params) {
        return this.engine.sequence(params);
    }
    getProperties(name) {
        return this.defs[name].properties || {};
    }
    getApiForAnimation(name) {
        return this.defs[name].api || {};
    }
    _resetRegistrations() {
        this.defs = {};
    }
}
//# sourceMappingURL=AnimationsKit.js.map