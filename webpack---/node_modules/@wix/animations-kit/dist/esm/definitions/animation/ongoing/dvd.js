import {
    __rest
} from "tslib";
import {
    getDistance
} from '../../../utils/animationsUtils';
const name = 'DVD';
const properties = {
    schema: {},
};
const RIGHT = 1;
const LEFT = -1;
const DOWN = 1;
const UP = -1;
/**
 * get the duration of each frame of the animation based on the distance between the points relative to the duration
 * calculated for the container diagonal.
 */
function getFramesDuration(points, duration, containerWidth, containerHeight) {
    const containerDiagonal = Math.sqrt(Math.pow(containerHeight, 2) + Math.pow(containerWidth, 2));
    const distances = points.map((point, index, _points) => {
        const nextPoint = _points[index + 1];
        const distance = nextPoint ? getDistance(point, nextPoint) : 0;
        return (distance / containerDiagonal) * duration;
    });
    return distances;
}
/**
 * Given a container size and dimentions of an element, return the points the element should travel to in order to bounce off the walls of its container
 * and return to its original position
 */
function getTravelPoints({
    left,
    top,
    width,
    height
}, containerWidth, containerHeight) {
    // Define the initial point
    const initialPoint = {
        x: left,
        y: top
    };
    // Define the end point as the closest point on a wall 45deg behind the initial point
    const endPoint = left > top ? {
        x: left - top,
        y: 0
    } : {
        x: 0,
        y: top - left
    };
    // The precision in pixels to consider a point to be the last point
    const precision = 30;
    const points = [initialPoint];
    // initial direction is down-right
    const direction = {
        x: RIGHT,
        y: DOWN
    };
    // The distance of a point from the next wall in a given direction
    const distances = {
        [`${LEFT}${UP}`]: (x, y) => Math.min(x, y),
        [`${LEFT}${DOWN}`]: (x, y) => Math.min(x, containerHeight - (y + height)),
        [`${RIGHT}${UP}`]: (x, y) => Math.min(y, containerWidth - (x + width)),
        [`${RIGHT}${DOWN}`]: (x, y) => Math.min(containerHeight - (y + height), containerWidth - (x + width)),
    };
    while (getDistance(endPoint, points[points.length - 1]) >= precision ||
        !(direction.x === RIGHT && direction.y === DOWN)) {
        const {
            x,
            y
        } = points[points.length - 1];
        const dirKey = `${direction.x}${direction.y}`;
        const distance = distances[dirKey](x, y);
        const point = {
            x: x + distance * direction.x,
            y: y + distance * direction.y,
        };
        points.push(point);
        direction.x =
            point.x + width >= containerWidth ?
            LEFT :
            point.x <= 0 ?
            RIGHT :
            direction.x;
        direction.y =
            point.y + height >= containerHeight ?
            UP :
            point.y <= 0 ?
            DOWN :
            direction.y;
    }
    return [...points, initialPoint];
}
const powerMap = {
    soft: {
        spinDeg: 0,
        scale: 1
    },
    medium: {
        spinDeg: 45,
        scale: 1
    },
    hard: {
        spinDeg: 45,
        scale: 0.8
    },
};
/**
 * DVD animation object
 */
function animate(kit, elements, duration, delay, _a = {}) {
    var {
        power = 'soft'
    } = _a, params = __rest(_a, ["power"]);
    const sequence = kit.sequence(params);
    elements.forEach((element) => {
        const {
            offsetWidth: containerWidth,
            offsetHeight: containerHeight
        } = element.offsetParent;
        const compRect = kit.engine.getBoundingRect(element);
        const points = getTravelPoints(compRect, containerWidth, containerHeight);
        const durations = getFramesDuration(points, duration, containerWidth, containerHeight);
        points.forEach(({
            x,
            y
        }, index) => {
            const translateX = x - compRect.left;
            const translateY = y - compRect.top;
            const travelDuration = index > 0 ? durations[index - 1] : 0;
            const {
                spinDeg,
                scale
            } = powerMap[power];
            sequence.add([
                kit.animate('BasePosition', elements, travelDuration, delay, {
                    to: {
                        x: translateX,
                        y: translateY,
                    },
                    ease: 'linear',
                }),
                kit.animate('BaseRotate', elements, travelDuration, delay, {
                    to: {
                        rotation: `+=${spinDeg * travelDuration}deg`,
                    },
                    ease: 'linear',
                }),
                kit.animate('BaseScale', elements, travelDuration, delay, {
                    to: {
                        scale: index % 2 === 0 ? 1 : scale,
                    },
                    ease: 'linear',
                }),
            ]);
        });
    });
    return sequence.get();
}
export {
    name,
    properties,
    animate
};
//# sourceMappingURL=dvd.js.map