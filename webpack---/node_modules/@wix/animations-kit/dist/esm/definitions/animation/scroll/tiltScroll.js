import {
    __rest
} from "tslib";
const name = 'TiltScroll';
const properties = {
    schema: {},
};
const ease = 'linear';
const MAX_Y_TRAVEL = 40;
const [ROTATION_X, ROTATION_Y, ROTATION_Z] = [10, 25, 25];
const [UP, DOWN, ORIGINAL_LAYOUT] = [-1, 1, 0];
const powerMap = {
    soft: {
        travelY: 0
    },
    medium: {
        travelY: 0.5
    },
    hard: {
        travelY: 1
    },
};
const directionMap = {
    right: 1,
    left: -1,
};
const rangeValues = { in: {
        fromValues: {
            rotations: [-1, -1, 1],
            travelY: DOWN,
        },
        toValues: {
            rotations: [0, 0, -1],
            travelY: ORIGINAL_LAYOUT,
        },
    },
    out: {
        fromValues: {
            rotations: [0, 0, 0],
            travelY: ORIGINAL_LAYOUT,
        },
        toValues: {
            rotations: [-1, -1, 1],
            travelY: UP,
        },
    },
    continuous: {
        fromValues: {
            rotations: [-1, -1, -1],
            travelY: DOWN,
        },
        toValues: {
            rotations: [1, 0.5, 1.25],
            travelY: UP
        },
    },
};

function getYTravel(distance, power) {
    return (typeof power !== 'undefined' ?
        powerMap[power].travelY :
        distance) * -MAX_Y_TRAVEL;
}
/**
 * TiltScroll
 */
function animate(kit, elements, _duration, _delay, _a = {}) {
    var {
        power,
        speed = 0,
        range = 'in',
        direction = 'right'
    } = _a, params = __rest(_a, ["power", "speed", "range", "direction"]);
    const sequence = kit.sequence(params);
    const {
        fromValues,
        toValues
    } = rangeValues[range];
    const [rotateXFrom, rotateYFrom, rotateZFrom, rotateXTo, rotateYTo, rotateZTo] = [...fromValues.rotations, ...toValues.rotations];
    const [travelYFromDir, travelYToDir] = [fromValues.travelY, toValues.travelY];
    const dir = directionMap[direction];
    const rotateZFromStr = `${rotateZFrom < 0 ? '-=' : '+='}${Math.abs(rotateZFrom * ROTATION_Z) * dir}deg`;
    const rotateZToStr = `${rotateZTo < 0 ? '-=' : '+='}${Math.abs(rotateZTo * ROTATION_Z) * dir}deg`;
    const travelY = getYTravel(speed, power);
    const travelYFrom = travelY * travelYFromDir;
    const travelYTo = travelY * travelYToDir;
    sequence.add([
        kit.animate('BaseRotate3D', elements, 1000, 0, {
            from: {
                rotationX: rotateXFrom * ROTATION_X,
                rotationY: rotateYFrom * ROTATION_Y,
                transformPerspective: 400,
            },
            to: {
                rotationX: rotateXTo * ROTATION_X,
                rotationY: rotateYTo * ROTATION_Y,
                transformPerspective: 400,
            },
            ease,
        }),
        kit.animate('BaseRotate', elements, 1000, 0, {
            from: {
                rotation: rotateZFromStr
            },
            to: {
                rotation: rotateZToStr
            },
            ease: 'sineInOut',
        }),
        kit.animate('BasePosition', elements, 1000, 0, {
            from: {
                y: `${travelYFrom}vh`
            },
            to: {
                y: `${travelYTo}vh`
            },
            ease: 'linear',
        }),
    ]);
    return sequence.get();
}
const api = {
    getScrubOffsets({
        power,
        range = 'in',
        speed = 0,
    }) {
        const offset = Math.abs(getYTravel(speed, power));
        return {
            start: range === 'out' ? '0px' : `${-offset}vh`,
            end: range === 'in' ? '0px' : `${offset}vh`,
        };
    },
};
export {
    name,
    properties,
    animate,
    api
};
//# sourceMappingURL=tiltScroll.js.map