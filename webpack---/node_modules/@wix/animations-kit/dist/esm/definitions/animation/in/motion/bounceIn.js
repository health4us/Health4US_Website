import {
    __rest
} from "tslib";
import {
    getAdjustedDirection,
    keyframesToDuration,
    getEasingFamily,
} from '../../../../utils/animationsUtils';
const name = 'BounceIn';
const properties = {
    schema: {},
};
const { in: _in, out: _out
} = getEasingFamily('sine');
const keyframes_distance = [{
        keyframe: 0,
        translate: 100,
        ease: _out
    },
    {
        keyframe: 30,
        translate: 0,
        ease: _in
    },
    {
        keyframe: 42,
        translate: 35,
        ease: _out
    },
    {
        keyframe: 54,
        translate: 0,
        ease: _in
    },
    {
        keyframe: 62,
        translate: 21,
        ease: _out
    },
    {
        keyframe: 74,
        translate: 0,
        ease: _in
    },
    {
        keyframe: 82,
        translate: 9,
        ease: _out
    },
    {
        keyframe: 90,
        translate: 0,
        eaee: _in
    },
    {
        keyframe: 95,
        translate: 2,
        ease: _out
    },
    {
        keyframe: 100,
        translate: 0,
        ease: _in
    },
];
const powerMap = {
    soft: {
        distanceFactor: 1
    },
    medium: {
        distanceFactor: 2
    },
    hard: {
        distanceFactor: 3
    },
};
const paramsMap = {
    top: {
        y: -1,
        x: 0,
        z: 0,
        idx: 0
    },
    right: {
        y: 0,
        x: 1,
        z: 0,
        idx: 1
    },
    bottom: {
        y: 1,
        x: 0,
        z: 0,
        idx: 2
    },
    left: {
        y: 0,
        x: -1,
        z: 0,
        idx: 3
    },
};
const centerParams = {
    x: 0,
    y: 0,
    z: -1
};

function animate(kit, elements, duration, delay, _a = {}) {
    var {
        power,
        distanceFactor = 1,
        direction = 'bottom'
    } = _a, params = __rest(_a, ["power", "distanceFactor", "direction"]);
    const sequence = kit.sequence(params);
    distanceFactor =
        typeof power === 'undefined' ?
        distanceFactor :
        powerMap[power].distanceFactor;
    const durations = keyframesToDuration(keyframes_distance, duration);
    if (direction === 'center') {
        sequence.add(kit.engine.set(elements, {
            transformPerspective: 800
        }), 0);
    }
    elements.forEach((element) => {
        const elementAngleInDeg = Number(kit.engine.getProperty(element, '--comp-rotate-z') || 0);
        const adjDirection = direction === 'center' ?
            'center' :
            getAdjustedDirection(paramsMap, direction, elementAngleInDeg);
        const {
            x,
            y,
            z
        } = adjDirection === 'center' ? centerParams : paramsMap[adjDirection];
        const first_frame = keyframes_distance[0];
        sequence.add(kit.animate('BasePosition', element, 0, delay, {
            from: {
                x: `${(x * first_frame.translate * distanceFactor) / 2}px`,
                y: `${(y * first_frame.translate * distanceFactor) / 2}px`,
                z: `${(z * first_frame.translate * distanceFactor) / 2}px`,
            },
        }), 0);
        keyframes_distance.forEach(({
            translate,
            ease
        }, index) => {
            sequence.add(kit.animate('BasePosition', element, durations[index], 0, {
                to: {
                    x: `${(x * translate * distanceFactor) / 2}px`,
                    y: `${(y * translate * distanceFactor) / 2}px`,
                    z: `${(z * translate * distanceFactor) / 2}px`,
                },
                ease,
            }));
        });
    });
    sequence.add(kit.animate('BaseFade', elements, (duration * keyframes_distance[3].keyframe) / 100, delay, {
        from: {
            opacity: 0
        },
        to: {
            opacity: 1
        },
        ease: 'quadOut',
    }), 0);
    return sequence.get();
}
export {
    name,
    properties,
    animate
};
//# sourceMappingURL=bounceIn.js.map