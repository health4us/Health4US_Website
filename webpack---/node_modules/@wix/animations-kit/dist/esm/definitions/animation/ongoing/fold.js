import {
    __rest
} from "tslib";
import {
    getEasingFamily,
    getElementTransformedPosition,
} from '../../../utils/animationsUtils';
import {
    deg2rad
} from '@wix/wow-utils';
const name = 'Fold';
const properties = {
    schema: {},
};
const MIN_ROTATE_ANGLE = 15;
const powerMap = {
    soft: {
        rotationFactor: 1
    },
    medium: {
        rotationFactor: 2
    },
    hard: {
        rotationFactor: 3
    },
};
const directionMap = {
    top: {
        rotationAxis: 'rotationX',
        transformOrigin: '50% 0'
    },
    right: {
        rotationAxis: 'rotationY',
        transformOrigin: '100% 50%'
    },
    bottom: {
        rotationAxis: 'rotationX',
        transformOrigin: '50% 100%'
    },
    left: {
        rotationAxis: 'rotationY',
        transformOrigin: '0 50%'
    },
};

function getDelaySequence(angle, time) {
    return [{
            fold: angle * -0.7,
            frameTime: time
        },
        {
            fold: angle * 0.6,
            frameTime: time
        },
        {
            fold: angle * -0.3,
            frameTime: time * 0.9
        },
        {
            fold: angle * 0.2,
            frameTime: time * 0.8
        },
        {
            fold: angle * -0.05,
            frameTime: time
        },
        {
            fold: 0,
            frameTime: time * 0.7
        },
    ];
}
/**
 * Fold animation object
 */
function animate(kit, elements, duration, repeatDelay, _a = {}) {
    var {
        direction = 'top', power, angle = MIN_ROTATE_ANGLE, easing = 'cubicInOut'
    } = _a, params = __rest(_a, ["direction", "power", "angle", "easing"]);
    const sequence = kit.sequence(params);
    const isResponsive = typeof power === 'undefined';
    const {
        rotationAxis,
        transformOrigin
    } = directionMap[direction];
    const ease = getEasingFamily(isResponsive ? easing : 'cubicInOut');
    const rotation = isResponsive ?
        angle :
        MIN_ROTATE_ANGLE * powerMap[power].rotationFactor;
    elements.forEach((element) => {
        const elementAngleInDeg = Number(kit.engine.getProperty(element, '--comp-rotate-z') || 0);
        const origin = transformOrigin.split(' ');
        const {
            x,
            y
        } = getElementTransformedPosition({
            x: origin[0],
            y: origin[1]
        }, kit.engine.getBoundingRect(element), deg2rad(elementAngleInDeg));
        sequence.add(kit.engine.set(element, {
            x,
            y,
            transformOrigin,
            transformPerspective: 800,
        }));
    });
    sequence.add(kit.animate('BaseRotate3D', elements, duration / 4, 0, {
        to: {
            [rotationAxis]: `${rotation}deg`
        },
        ease: ease.out,
    }));
    if (repeatDelay) {
        // in case a delay is applied, animate a different sequence which decays to a stop
        const delaySequence = getDelaySequence(rotation, duration / 2);
        delaySequence.forEach(({
            fold,
            frameTime
        }) => sequence.add(kit.animate('BaseRotate3D', elements, frameTime, 0, {
            to: {
                [rotationAxis]: `${fold}deg`
            },
            ease: 'sineInOut',
        })));
        sequence.add(kit.animate('BaseNone', elements, repeatDelay, 0)); // add repeat delay
    } else {
        sequence
            .add(kit.animate('BaseRotate3D', elements, duration / 2, 0, {
                to: {
                    [rotationAxis]: `${-rotation}deg`
                },
                ease: ease.inOut,
            }))
            .add(kit.animate('BaseRotate3D', elements, duration / 4, 0, {
                to: {
                    [rotationAxis]: 0
                },
                ease: ease.in,
            }));
    }
    return sequence.get();
}
export {
    name,
    properties,
    animate
};
//# sourceMappingURL=fold.js.map