/**
 * Round a number to the closest multiply of 'step'
 *
 * @param step - The step value to round to
 * @param num - The number to round
 * @returns The rounded number
 */
export function round(step, num) {
    const mod = step ? num % step : 0;
    return mod > step / 2 ? num - mod + step : num - mod;
}

/**
 * Round with decimal precision, default round to integer
 *
 * @param num - The number to round
 * @param precision - The decimal precision (default: 0)
 * @returns The rounded number
 */
export const roundPrecision = function(num, precision) {
    if (precision === void 0) {
        precision = 0;
    }
    return +num.toFixed(precision);
};

/**
 * Limit a number between 2 values, inclusive
 *
 * @param min - The minimum value
 * @param max - The maximum value
 * @param num - The number to clamp
 * @returns The clamped number
 */
export function clamp(min, max, num) {
    return Math.min(max, Math.max(min, num));
}

/**
 * Snap a number by distance to another number
 *
 * @param to - The target number to snap to
 * @param dist - The distance threshold
 * @param num - The number to snap
 * @returns The snapped number
 */
export function snap(to, dist, num) {
    return Math.abs(num - to) <= dist ? to : num;
}

/**
 * Snap a number by distance every multiple of another number
 *
 * @param to - The target number to snap to
 * @param dist - The distance threshold
 * @param num - The number to snap
 * @returns The snapped number
 */
export function snapEvery(to, dist, num) {
    const d1 = num % to;
    const d2 = to - d1;
    return d1 <= dist ? num - d1 : d2 <= dist ? num + d2 : num;
}

/**
 * Linear Interpolation
 * If t = 0 returns a, if t = 1 returns b, and transitions the value in-between
 *
 * @param a - The start value
 * @param b - The end value
 * @param t - The interpolation factor
 * @returns The interpolated value
 */
export function lerp(a, b, t) {
    return a * (1 - t) + b * t;
}

/**
 * Map a value from one range 'a' to different range 'b'
 *
 * @param sourceMin - The minimum value of the source range
 * @param sourceMax - The maximum value of the source range
 * @param targetMin - The minimum value of the target range
 * @param targetMax - The maximum value of the target range
 * @param num - The number to map
 * @returns The mapped value
 */
export function mapRange(sourceMin, sourceMax, targetMin, targetMax, num) {
    return (num - sourceMin) * (targetMax - targetMin) / (sourceMax - sourceMin) + targetMin;
}

/**
 * Map a number from a range to a fraction between 0 and 1
 *
 * @param start - The start value of the range
 * @param end - The end value of the range
 * @param num - The number to map
 * @returns The mapped value
 */
export function mapPercentage(start, end, num) {
    return mapRange(start, end, 0, 1, num);
}

/**
 * Get the distance between 2 points
 *
 * @param p1 - The first point [x1, y1]
 * @param p2 - The second point [x2, y2]
 * @returns The distance between the two points
 */
export function distance(_ref, _ref2) {
    let [x1, y1] = _ref;
    let [x2, y2] = _ref2;
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

/**
 * Convert degrees to radians
 *
 * @param angleInDeg - The angle in degrees
 * @returns The angle in radians
 */
export function deg2rad(angleInDeg) {
    return angleInDeg * Math.PI / 180;
}

/**
 * Convert radians to degrees
 *
 * @param angleInRad - The angle in radians
 * @returns The angle in degrees
 */
export function rad2deg(angleInRad) {
    return angleInRad * 180 / Math.PI;
}

/**
 * Get the angle between 2 points in degrees clamped between 0 and 360
 * Pass the third argument "offset" to rotate the angle source,
 * for example use 90 to move angle 0 to the top
 *
 * @param p1 - The first point [x1, y1]
 * @param p2 - The second point [x2, y2]
 * @param offset - The angle offset (default: 0)
 * @returns The angle between the two points in degrees
 */
export function getAngleInDeg(p1, p2, offset) {
    if (p1 === void 0) {
        p1 = [0, 0];
    }
    if (p2 === void 0) {
        p2 = [0, 0];
    }
    if (offset === void 0) {
        offset = 0;
    }
    const angle = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]) * 180 / Math.PI;
    return (360 + offset + angle) % 360;
}
//# sourceMappingURL=math-and-numbers.js.map