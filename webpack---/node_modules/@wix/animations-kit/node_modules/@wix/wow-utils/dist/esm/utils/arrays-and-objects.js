/**
 * Check if value is iterable
 *
 * @param value - The value to check.
 * @returns A boolean indicating whether the value is iterable.
 */
export const isIterable = value => value !== null && Symbol.iterator in Object(value);

/**
 * Convert value to array:
 * if it's iterable, convert to an array
 * if it's null, return an empty array
 * if it's not iterable, return an array with the value as the only element
 *
 * @param obj - The value to convert to an array.
 * @returns An array representation of the value.
 */
export const toArray = function(obj) {
    if (obj === void 0) {
        obj = [];
    }
    return isIterable(obj) && typeof obj !== 'string' ? Array.from(obj) : obj === null ? [] : [obj];
};

/**
 * Union arrays.
 * Changed to a better implementation from here https://stackoverflow.com/a/27664971
 *
 * @param arr - The arrays to union.
 * @returns A new array containing the union of all input arrays.
 */
export const unionArrays = function() {
    return Array.from(new Set([].concat(...arguments)));
};

/**
 * Omit keys from object, return new object.
 * Like lodash _.omit.
 *
 * @param obj - The original object.
 * @param keys - An array of keys to be omitted from the object.
 * @returns A new object without the specified keys.
 */
export const omit = (obj, keys) => Object.fromEntries(Object.entries(obj).filter(_ref => {
    let [key] = _ref;
    return !keys.includes(key);
}));
//# sourceMappingURL=arrays-and-objects.js.map