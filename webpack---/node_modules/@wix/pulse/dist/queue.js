import {
    webVitalsReport180 as webVitalsReport,
    pulseError,
} from '@wix/bi-logger-pulse/v2';
import {
    normalizeUrl
} from './utils/url';
import {
    getHtmlElementMetadataWrapper,
    toPulseMetric
} from './pulse-metric';
import {
    logBiWithEssentials
} from './utils/log-bi-with-essential';
export default class Queue {
    // Internal business logic
    _map = new Map();
    _biLogger;
    _pulseLogger;
    // Data added to the event
    _navigationId;
    _navType;
    _url;
    _platform;
    _sessionId;
    _vsi;
    _msid;
    _uuid;
    _getHtmlElementMetadata = () => ({
        compType: 'pulse-not-initialized'
    });
    constructor({
        url,
        platform,
        biLogger,
        pulseLogger,
        navigationId,
        navType,
        sessionId,
        vsi,
        msid,
        uuid,
        getHtmlElementMetadata,
    }) {
        this._url = normalizeUrl(url);
        this._platform = platform;
        this._biLogger = biLogger;
        this._pulseLogger = pulseLogger;
        this._navigationId = navigationId;
        this._navType = navType;
        this._sessionId = sessionId;
        this._vsi = vsi;
        this._msid = msid;
        this._uuid = uuid;
        this.getHtmlElementMetadata = getHtmlElementMetadata;
    }
    set getHtmlElementMetadata(getHtmlElementMetadata) {
        this._getHtmlElementMetadata = getHtmlElementMetadataWrapper(getHtmlElementMetadata);
    }
    flushQueue() {
        if (this._map.size > 0) {
            // We want to avoid throwing uncaught exceptions since we're running in the platform.
            try {
                let webVitals = {};
                const metadataObject = {};
                for (const [metricName, pulseMetric] of this._map.entries()) {
                    const {
                        metadata: metricMetadata,
                        ...rest
                    } = pulseMetric;
                    if (metricMetadata) {
                        metadataObject[metricName] = metricMetadata;
                    }
                    webVitals = {
                        ...webVitals,
                        ...rest,
                    };
                }
                let metadata;
                try {
                    if (Object.keys(metadataObject).length > 0) {
                        metadata = JSON.stringify(metadataObject);
                    }
                } catch (e) {
                    metadata = 'Failed to stringify metadata';
                    this._reportErrorToBi(e, 'Stringify Metadata');
                }
                const event = webVitalsReport({
                    platform: this._platform,
                    url: this._url,
                    navigationId: this._navigationId,
                    navType: this._navType,
                    ...webVitals,
                    metadata,
                    sessionId: this._sessionId,
                    ...(this._msid && {
                        msid: this._msid
                    }),
                    ...(this._vsi && {
                        vsi: this._vsi
                    }),
                    ...(this._uuid && {
                        uuid: this._uuid
                    }),
                });
                logBiWithEssentials(this._biLogger, event);
                this._pulseLogger.info('Flushing queue', event);
            } catch (e) {
                this._pulseLogger.error('Failed to flush queue', e);
                this._reportErrorToBi(e, 'Flush Queue');
            }
            this._map.clear();
        }
    }
    addToQueue(metric) {
        this._pulseLogger.info(`Adding metric to queue: ${metric.name}`, metric);
        let pulseMetric;
        try {
            pulseMetric = toPulseMetric(metric, this._getHtmlElementMetadata);
        } catch (e) {
            pulseMetric = {
                metadata: {
                    error: `Error converting ${metric.name} to PulseMetric`
                },
            };
            this._reportErrorToBi(e, `Convert Metric ${metric.name}`);
        }
        this._map.set(metric.name, pulseMetric);
    }
    _reportErrorToBi(e, step) {
        logBiWithEssentials(this._biLogger, pulseError({
            platform: this._platform,
            sessionId: this._sessionId,
            ...(this._msid && {
                msid: this._msid
            }),
            ...(this._vsi && {
                vsi: this._vsi
            }),
            ...(this._uuid && {
                uuid: this._uuid
            }),
            message: e instanceof Error ? e.message : 'No error message',
            step,
        }));
    }
}
//# sourceMappingURL=queue.js.map