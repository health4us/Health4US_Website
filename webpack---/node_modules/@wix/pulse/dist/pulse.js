import {
    onTTFB,
    onFCP,
    onLCP,
    onCLS,
    onINP,
} from 'web-vitals/attribution';
import Queue from './queue';
import {
    createPulseLogger
} from './utils/pulse-logger';
import {
    pulseError,
    pulseInitialized,
    pulseUpdated,
} from '@wix/bi-logger-pulse/v2';
import {
    logBiWithEssentials
} from './utils/log-bi-with-essential';
export class Pulse {
    _platform;
    _biLogger;
    _reportSoftNavs = false;
    _debug = false;
    _queues = new Map();
    _url = window.location.href;
    _pulseLogger;
    _sessionId;
    _vsi;
    _msid;
    _uuid;
    _getHtmlElementMetadata = () => ({});
    constructor(config) {
        this._platform = config.platform;
        // If a biLoggerFactory is provided, use it to create a biLogger instance.
        if (!config.biLoggerFactory && !config.biLogger) {
            throw new Error(`biLogger or biLoggerFactory must be provided`);
        }
        this._biLogger = config.biLoggerFactory ?
            config.biLoggerFactory({
                useBatch: true
            }).logger() :
            config.biLogger;
        // We want to report Pulse initialization as soon as we can
        logBiWithEssentials(this._biLogger, pulseInitialized({
            sessionId: config.sessionId,
            platform: config.platform,
            ...(config.msid && {
                msid: config.msid
            }),
            ...(config.vsi && {
                vsi: config.vsi
            }),
            ...(config.uuid && {
                uuid: config.uuid
            }),
        }));
        this._reportSoftNavs = config.reportSoftNavs || false;
        this._debug = config.debug || false;
        this._sessionId = config.sessionId;
        this._vsi = config.vsi;
        this._msid = config.msid;
        this._uuid = config.uuid;
        if (config.getHtmlElementMetadata) {
            this._getHtmlElementMetadata = config.getHtmlElementMetadata;
        }
        const searchQuery = new URLSearchParams(window.location.search);
        this._pulseLogger = createPulseLogger(this._debug || searchQuery.has('debugPulse'));
        try {
            this._initListeners();
        } catch (e) {
            console.error('Failed to initialze Pulse listeners', e);
            this._reportErrorToBi(e, 'Pulse Listeners Initialization');
        }
    }
    update({
        getHtmlElementMetadata,
    }) {
        // We want to report Pulse update as soon as we can
        try {
            logBiWithEssentials(this._biLogger, pulseUpdated({
                sessionId: this._sessionId,
                platform: this._platform,
                ...(this._msid && {
                    msid: this._msid
                }),
                ...(this._vsi && {
                    vsi: this._vsi
                }),
                ...(this._uuid && {
                    uuid: this._uuid
                }),
            }));
            this._getHtmlElementMetadata = getHtmlElementMetadata;
            // Update all queues with the new getHtmlElementMetadata function
            for (const queue of this._queues.values()) {
                queue.getHtmlElementMetadata = this._getHtmlElementMetadata;
            }
        } catch (e) {
            console.error('Failed update Pulse', e);
            this._reportErrorToBi(e, 'Pulse Update');
        }
    }
    addMetricToQueue(metric) {
        const {
            navigationId,
            navigationType: navType
        } = metric;
        if (!this._queues.has(navigationId.toString())) {
            this._queues.set(navigationId.toString(), new Queue({
                url: this._url,
                platform: this._platform,
                biLogger: this._biLogger,
                pulseLogger: this._pulseLogger,
                sessionId: this._sessionId,
                ...(this._vsi && {
                    vsi: this._vsi
                }),
                ...(this._msid && {
                    msid: this._msid
                }),
                ...(this._uuid && {
                    uuid: this._uuid
                }),
                getHtmlElementMetadata: this._getHtmlElementMetadata,
                navigationId: navigationId.toString(),
                navType,
            }));
        }
        this._queues.get(navigationId.toString()) ? .addToQueue(metric);
    }
    _flushQueues() {
        for (const queue of this._queues.values()) {
            queue.flushQueue();
        }
    }
    _initListeners() {
        const promisify = (onXXX, options) => new Promise((resolve) => onXXX((metric) => {
            this.addMetricToQueue(metric);
            resolve(undefined);
        }, options));
        const basicWebVitalsPromises = Promise.all([
            promisify(onTTFB, {
                reportSoftNavs: this._reportSoftNavs,
            }),
            promisify(onFCP, {
                reportSoftNavs: this._reportSoftNavs,
            }),
            promisify(onLCP, {
                reportSoftNavs: this._reportSoftNavs,
            }),
        ]);
        onCLS((metric) => this.addMetricToQueue(metric), {
            reportSoftNavs: this._reportSoftNavs,
        });
        onINP((metric) => this.addMetricToQueue(metric), {
            reportSoftNavs: this._reportSoftNavs,
            reportAllChanges: true,
        });
        // Still using this so it will works for CLS and INP
        // Report all available metrics whenever the page is backgrounded or unloaded.
        addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                basicWebVitalsPromises.then(() => {
                    this._flushQueues();
                });
            }
        });
        // NOTE: Safari does not reliably fire the `visibilitychange` event when the
        // page is being unloaded. If Safari support is needed, you should also flush
        // the queue in the `pagehide` event.
        addEventListener('pagehide', () => {
            basicWebVitalsPromises.then(() => {
                this._flushQueues();
            });
        });
    }
    _reportErrorToBi(e, step) {
        logBiWithEssentials(this._biLogger, pulseError({
            platform: this._platform,
            sessionId: this._sessionId,
            ...(this._msid && {
                msid: this._msid
            }),
            ...(this._vsi && {
                vsi: this._vsi
            }),
            ...(this._uuid && {
                uuid: this._uuid
            }),
            message: e instanceof Error ? e.message : 'No error message',
            step,
        }));
    }
}
//# sourceMappingURL=pulse.js.map