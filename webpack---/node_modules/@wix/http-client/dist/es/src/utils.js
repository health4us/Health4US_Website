import {
    SSR_HOST,
    SSR_PROTOCOL
} from './constants';
import {
    isBrowser,
    isNode,
    isWebWorker
} from './env-util';
export function isAbsoluteUrl(url) {
    if (typeof url !== 'string') {
        throw new TypeError(`Expected a \`string\`, got \`${typeof url}\``);
    }
    return /(^https?:)|(^\/\/)/.test(url);
}
export async function silent(fn) {
    try {
        await fn();
    } catch (_a) {}
}
export function extractProp(data, path) {
    return path
        .split('.')
        .filter((prop) => prop)
        .reduce((result, prop) => result[prop], data);
}
export function resolveHost(opts) {
    if (opts.baseURL) {
        return extractHost(opts.baseURL);
    } else if (opts.isSSR) {
        return SSR_HOST;
    } else if (typeof self !== 'undefined' && !!self.location) {
        return self.location.host;
    } else {
        return '';
    }
}
export function resolveProtocol(opts) {
    if (opts.baseURL) {
        return extractProtocol(opts.baseURL);
    } else if (opts.isSSR) {
        return SSR_PROTOCOL;
    } else if (typeof self !== 'undefined' && !!self.location) {
        return self.location.protocol;
    } else {
        return '';
    }
}
export function extractProtocol(url) {
    try {
        const asUrl = new URL(url);
        return asUrl.protocol;
    } catch (_a) {
        const hostAndProtocol = extractHostAndProtocolUsingRegExp(url);
        return hostAndProtocol.protocol;
    }
}
export function extractHost(url) {
    let asUrl;
    try {
        asUrl = new URL(url);
    } catch (_a) {
        // in case of PRURL
        asUrl = new URL(`http:${url}`);
    }
    try {
        return asUrl.host;
    } catch (_b) {
        const hostAndProtocol = extractHostAndProtocolUsingRegExp(url);
        return hostAndProtocol.host;
    }
}
/**
 * In mobile URL object doesnt implement host / protocol
 * This function will try to resolve the host/protocol using regular expression.
 */
function extractHostAndProtocolUsingRegExp(url) {
    const regExp = new RegExp('^(.*:)//([A-Za-z0-9-.]+)(:[0-9]+)?(.*)$');
    try {
        const urlOptions = regExp.exec(url);
        return {
            protocol: urlOptions[1],
            host: urlOptions[2]
        };
    } catch (_a) {
        return {
            protocol: 'http:',
            host: ''
        };
    }
}
export function changeHost(urlOrPath, host) {
    let url;
    try {
        url = new URL(urlOrPath);
        url.host = host;
        url.protocol = 'http';
    } catch (_a) {
        url = new URL(`http://${host}`);
        url.pathname = urlOrPath;
    }
    return url.toString();
}
export function getGlobalConfig() {
    const defaultConfig = {
        httpMockServer: {
            enabled: false
        }
    };
    let globalConfig;
    if (isNode() && process.env.HTTP_CLIENT_GLOBAL_CONFIG) {
        try {
            globalConfig = JSON.parse(process.env.HTTP_CLIENT_GLOBAL_CONFIG);
        } catch (e) {}
    }
    if (!globalConfig) {
        if (isBrowser()) {
            globalConfig = window._httpClientGlobalConfig;
        } else if (isWebWorker()) {
            // TODO
        }
    }
    return globalConfig || defaultConfig;
}
export function isHttpMockServerEnabled() {
    const globalConfig = getGlobalConfig();
    return globalConfig.httpMockServer.enabled;
}
export function shouldAllowUnmocked() {
    const globalConfig = getGlobalConfig();
    return globalConfig.httpMockServer.allowUnmocked;
}
export function toSearchQueryParams(params) {
    return Object.entries(params)
        .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
        .flat()
        .join('&');
}
//# sourceMappingURL=utils.js.map