function getBorderSizes(element) {
    const computedStyle = window.getComputedStyle(element);
    return {
        top: parseFloat(computedStyle.getPropertyValue('border-top-width')),
        left: parseFloat(computedStyle.getPropertyValue('border-left-width')),
    };
}
const hasOverflow = (child) => window.getComputedStyle(child).getPropertyValue('overflow') === 'visible';
const getChildren = (element, tagNames) => Array.from(element.children || []).filter((child) => tagNames ? tagNames.includes(child.tagName.toLowerCase()) : true);
/**
 * Get an element dimensions and position relative to the *document* root and while ignoring all transforms
 * NOTE: To calculate relative to window, use getBoundingRect
 */
function getElementRect(element, offsetParent) {
    let top = element.offsetTop;
    let left = element.offsetLeft;
    const width = element.offsetWidth;
    const height = element.offsetHeight;
    while (element.offsetParent) {
        // @ts-expect-error
        element = element.offsetParent;
        const border = getBorderSizes(element);
        top += border.top;
        left += border.left;
        if (offsetParent && element === offsetParent) {
            break;
        }
        top += element.offsetTop;
        left += element.offsetLeft;
    }
    return {
        top,
        left,
        width,
        height,
        bottom: top + height,
        right: left + width,
    };
}
/**
 * Get an element dimensions and position relative to the *window* and while ignoring all transforms
 */
function getBoundingRect(element, offsetParent, scrollContainer = window) {
    const elementRect = getElementRect(element, offsetParent);
    if (scrollContainer) {
        const scrollY = scrollContainer.scrollY ||
            scrollContainer.scrollTop ||
            0;
        const scrollX = scrollContainer.scrollX ||
            scrollContainer.scrollLeft ||
            0;
        elementRect.top -= scrollY;
        elementRect.bottom -= scrollY;
        elementRect.left -= scrollX;
        elementRect.right -= scrollX;
    }
    return elementRect;
}
/**
 * Get an element and all it's children dimensions and position relative to the *document* root and while ignoring all transforms
 * If list of children is not provided, defaults to [div, section] children
 */
function getContentRect(element, offsetParent, tagNames = ['div', 'section'], contentRect = getElementRect(element, offsetParent)) {
    const elementChildren = getChildren(element, tagNames);
    elementChildren.forEach((child) => {
        const rect = getElementRect(child, offsetParent);
        // If child has no size, meaning it is hidden, don't calculate it
        if (rect.width > 0 && rect.height > 0) {
            if (rect.left < contentRect.left) {
                contentRect.left = rect.left;
            }
            if (rect.right > contentRect.right) {
                contentRect.right = rect.right;
            }
            if (rect.top < contentRect.top) {
                contentRect.top = rect.top;
            }
            if (rect.bottom > contentRect.bottom) {
                contentRect.bottom = rect.bottom;
            }
        }
        // if a child overflow value is 'visible', calculate their sizes too
        if (hasOverflow(child)) {
            getContentRect(child, offsetParent, tagNames, contentRect);
        }
    });
    contentRect.width = contentRect.right - contentRect.left;
    contentRect.height = contentRect.bottom - contentRect.top;
    return contentRect;
}
/**
 * Get an element and all it's children dimensions and position relative to the *window* and while ignoring all transforms
 */
function getBoundingContentRect(element, offsetParent, tagNames, scrollContainer = window) {
    const elementRect = getContentRect(element, offsetParent, tagNames);
    if (scrollContainer) {
        const scrollY = scrollContainer.scrollY ||
            scrollContainer.scrollTop ||
            0;
        const scrollX = scrollContainer.scrollX ||
            scrollContainer.scrollLeft ||
            0;
        elementRect.top -= scrollY;
        elementRect.bottom -= scrollY;
        elementRect.left -= scrollX;
        elementRect.right -= scrollX;
    }
    return elementRect;
}
export {
    getElementRect,
    getBoundingRect,
    getContentRect,
    getBoundingContentRect,
};
//# sourceMappingURL=index.js.map