import axios from 'axios';
import xhrAdapter from 'axios/lib/adapters/xhr';
import {
    NO_SCENARIO_FOUND,
    SSR_HOST,
    SSR_PROTOCOL
} from './constants';
import {
    isBrowser,
    isNode
} from './env-util';
import {
    createHttpError
} from './error';
import {
    isWixDomain,
    requestIdOrEmptyString
} from './headers';
import {
    buildAllHeaders,
    buildOptions,
    getUrlHeaders,
} from './options';
import {
    extractProp,
    getGlobalConfig,
    isHttpMockServerEnabled,
    resolveHost,
    resolveProtocol,
    shouldAllowUnmocked,
    silent,
} from './utils';
export class HttpClient {
    constructor(opts = {}) {
        this.opts = opts;
        this.opts = defaultClientOptions(this.opts);
        this.client = axios.create(this.opts);
        this.flags = {
            sanitizerPocEnabled: checkSanitizerPocEnabled(),
        };
    }
    static isHttpError(payload) {
        return !!(payload === null || payload === void 0 ? void 0 : payload.isWixHttpError);
    }
    async request(requestOptionsOrFactory, overrides) {
        var _a, _b;
        const host = resolveHost(this.opts);
        const protocol = resolveProtocol(this.opts);
        const urlObject = {
            protocol,
            host
        };
        const requestOptions = typeof requestOptionsOrFactory === 'function' ?
            requestOptionsOrFactory({
                isSSR: this.opts.isSSR,
                host
            }) :
            requestOptionsOrFactory;
        const signedInstance = (overrides === null || overrides === void 0 ? void 0 : overrides.signedInstance) || (await ((_b = (_a = this.opts).getAppToken) === null || _b === void 0 ? void 0 : _b.call(_a))) || '';
        const headers = this.getHeaders(requestOptions, signedInstance, urlObject);
        const options = buildOptions({
            requestOptions,
            urlObject,
            headers,
            globalConfig: getGlobalConfig(),
        });
        if (this.opts.isSSR) {
            options.baseURL = this.opts.baseURL ?
                this.opts.baseURL :
                `${SSR_PROTOCOL}://${SSR_HOST}`;
        }
        try {
            const res = await this.client
                .request(options)
                .catch((err) => this.maybeFallbackRequest(err, requestOptions, urlObject, signedInstance));
            return this.transformResponse(res, requestOptions);
        } catch (e) {
            this.handleRequestError(e, options);
        }
    }
    async get(url, requestOptions) {
        const opts = Object.assign(Object.assign({}, requestOptions), {
            url,
            method: 'GET'
        });
        return this.request(opts);
    }
    async delete(url, requestOptions) {
        const opts = Object.assign(Object.assign({}, requestOptions), {
            url,
            method: 'DELETE'
        });
        return this.request(opts);
    }
    async head(url, requestOptions) {
        const opts = Object.assign(Object.assign({}, requestOptions), {
            url,
            method: 'HEAD'
        });
        return this.request(opts);
    }
    async options(url, requestOptions) {
        const opts = Object.assign(Object.assign({}, requestOptions), {
            url,
            method: 'OPTIONS'
        });
        return this.request(opts);
    }
    async post(url, data, requestOptions) {
        const opts = Object.assign(Object.assign({}, requestOptions), {
            url,
            data,
            method: 'POST'
        });
        return this.request(opts);
    }
    async put(url, data, requestOptions) {
        const opts = Object.assign(Object.assign({}, requestOptions), {
            url,
            data,
            method: 'PUT'
        });
        return this.request(opts);
    }
    async patch(url, data, requestOptions) {
        const opts = Object.assign(Object.assign({}, requestOptions), {
            url,
            data,
            method: 'PATCH'
        });
        return this.request(opts);
    }
    get CancelToken() {
        return axios.CancelToken;
    }
    get isCancel() {
        return axios.isCancel;
    }
    getHeaders(requestOptions, signedInstance, urlObject) {
        if (typeof this.opts.createHeaders === 'function') {
            return this.getCustomHeaders(requestOptions, signedInstance, urlObject);
        }
        const wixHeadersOpts = {
            signedInstance,
            artifactId: this.opts.artifactId,
            csrf: false /* axios handles xsrf */ ,
            multilingualOptions: this.opts.multilingualOptions,
        };
        return buildAllHeaders(requestOptions, wixHeadersOpts, getGlobalConfig(), urlObject);
    }
    getCustomHeaders(requestOptions, signedInstance, urlObject) {
        const {
            url
        } = requestOptions;
        const authHeader = signedInstance && isWixDomain(url) ?
            {
                authorization: signedInstance
            } :
            {};
        const customHeaders = this.opts.createHeaders();
        const originalUrlHeader = getUrlHeaders(getGlobalConfig(), requestOptions, urlObject);
        return Object.assign(Object.assign(Object.assign({}, originalUrlHeader), customHeaders), authHeader);
    }
    handleRequestError(error, requestOptions) {
        const requestError = createHttpError(error);
        silent(() => {
            var _a;
            return (_a = requestOptions.onError) === null || _a === void 0 ? void 0 : _a.call(requestOptions, requestError);
        });
        throw requestError;
    }
    maybeFallbackRequest(err, requestOptions, urlObject, signedInstance) {
        var _a, _b, _c;
        const shouldFallbackRequest = isHttpMockServerEnabled() &&
            shouldAllowUnmocked() &&
            ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 404 &&
            ((_c = (_b = err.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.msg) === NO_SCENARIO_FOUND;
        if (shouldFallbackRequest) {
            const headers = this.getHeaders(requestOptions, signedInstance, urlObject);
            const prodOptions = buildOptions({
                requestOptions,
                urlObject,
                headers,
            });
            return this.client.request(prodOptions);
        }
        throw err;
    }
    transformResponse(res, requestOptions) {
        const requestId = requestIdOrEmptyString(res);
        const data = transformData(res, requestOptions, this.flags);
        return Object.assign(Object.assign({}, res), {
            data,
            requestId
        });
    }
}
/** @deprecated Please use the instance method instead, eg, httpClient.CancelToken.source() */
HttpClient.CancelToken = axios.CancelToken;
/** @deprecated Please use the instance method instead, eg, httpClient.isCancel() */
HttpClient.isCancel = axios.isCancel;

function defaultClientOptions(opts) {
    let adapter = opts.adapter;
    if (!adapter) {
        // Default - related to 2 cases: Bundled to Client  / Bundled to Viewer (SSR - isolated VM)
        adapter = xhrAdapter;
        // 2 cases: Bundled to server (SSR) & classic Node (Not bundled at all) (axios needs to be in the node_modules)
        if (isNode()) {
            adapter = getNodeAdapter();
        }
    }
    return Object.assign({
        adapter,
        isSSR: false
    }, opts);
}

function getNodeAdapter() {
    // we use statically analyzable require calls to support bundlers: https://jira.wixpress.com/browse/APINF-172
    // https://github.com/webpack/webpack/issues/5939#issue-272316127
    if (typeof __webpack_require__ === 'function') {
        return __non_webpack_require__('axios/lib/adapters/http');
    }
    return require('axios/lib/adapters/http');
}

function transformData(res, requestOptions, flags) {
    let resData = sanitizeResponse(res, flags);
    if (requestOptions._pickResponseBody) {
        resData = extractProp(res.data, requestOptions._pickResponseBody);
    }
    if (requestOptions._logs) {
        const logs = extractProp(res.data, requestOptions._logs);
        if (logs === null || logs === void 0 ? void 0 : logs.length) {
            logs.map((log) => console.log(...log));
        }
    }
    return resData;
}

function sanitizeResponse(res, flags) {
    try {
        if (flags.sanitizerPocEnabled) {
            const start = performance.now();
            // @ts-expect-error
            const sanitizer = new Sanitizer();
            if (res.headers['content-type'].includes('application/json')) {
                console.log('[+] JSON Response detected, sanitizing data');
                const sanitizeStringValue = function(jsonResponse) {
                    try {
                        Object.keys(jsonResponse).forEach((key) => {
                            if (typeof jsonResponse[key] === 'string') {
                                jsonResponse[key] = sanitizer.sanitizeFor('span', jsonResponse[key]).innerHTML;
                            } else if (typeof jsonResponse[key] === 'object') {
                                jsonResponse[key] = sanitizeStringValue(jsonResponse[key]);
                            }
                        });
                        return jsonResponse;
                    } catch (error) {
                        console.log(error);
                    }
                };
                const end = performance.now();
                console.log(`Time taken: ${end - start} milliseconds.`);
                return sanitizeStringValue(res.data);
            }
        }
    } catch (e) {
        console.log('[+] Sanitizer API not supported: %o', e);
    }
    return res.data;
}

function checkSanitizerPocEnabled() {
    var _a;
    try {
        return (isBrowser() &&
            new URLSearchParams(((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.hash) || '').get('sanitizerPOC') ===
            'true');
    } catch (_b) {
        return false;
    }
}
export function createHttpClient(...args) {
    return new HttpClient(...args);
}
//# sourceMappingURL=http-client.js.map