/* eslint-disable no-nested-ternary */
/* eslint-disable no-new-func */
/* eslint-disable no-eval */
import {
    getLazyFactoryID
} from '@wix/editor-elements-conventions';
import {
    createException,
    RegistryErrorCode
} from '../createException';
import {
    isServer
} from '../utils';
import {
    consts
} from '../consts';
const workaround = {};
/**
 * trick to leave `require` as is after webpack build
 * it makes possible to run the same bundle on server and client
 */
export const initializeWorkaroundForRequire = (isExperimentOpen) => {
    if (!isNoEvalWorkaroundExperimentOn(isExperimentOpen)) {
        eval(`workaround.getRequireFunction = () => typeof require !== 'undefined' ? require : undefined`);
    }
};
export function getOriginalRequireFunction(isExperimentOpen) {
    return isNoEvalWorkaroundExperimentOn(isExperimentOpen) ?
        new Function("return typeof require !== 'undefined' ? require : undefined") :
        workaround.getRequireFunction();
}
export function isOriginalRequireFunctionAvailable(isExperimentOpen) {
    return typeof getOriginalRequireFunction(isExperimentOpen) !== 'undefined';
}
export function getGlobal() {
    return (typeof globalThis !== 'undefined' ?
        globalThis :
        typeof window !== 'undefined' ?
        window :
        typeof self !== 'undefined' ?
        self :
        typeof global !== 'undefined' ?
        global :
        null);
}
export function requireAMDModule(id, isExperimentOpen) {
    /**
     * This is workaround for webpack...
     * if just use `require` function directly, webpack will transpile it to
     * `__webpack_require__(n)` that always leads to module that throws exception like `module if not defined`
     */
    const localRequire = getOriginalRequireFunction(isExperimentOpen);
    return new Promise(resolve => {
        /**
         * Temporary fix for case where anonymous defines are declared in the environment.
         * It causes an Exception in requirejs: https://requirejs.org/docs/errors.html#mismatch
         * As introduced in this production bug: https://jira.wixpress.com/browse/ECL-7852
         * Better solution will follow.
         */
        if (isAnonymousDefineFixExperimentOn(isExperimentOpen)) {
            clearAnonymousDefines(localRequire);
        }
        /**
         * Trigger `require` to fix `require.specified`
         * https://github.com/requirejs/requirejs/issues/1305#issuecomment-87924865
         **/
        localRequire([]);
        /**
         * To prevent fetching module with `requirejs`
         */
        if (localRequire.specified(id)) {
            localRequire([id], (model) => {
                resolve(model);
            });
        } else {
            resolve(undefined);
        }
    });
}
const isAnonymousDefineFixExperimentOn = (isExperimentOpen) => typeof isExperimentOpen !== 'undefined' &&
    isExperimentOpen ? .(consts.experiments.fixAnonymousDefine);
const clearAnonymousDefines = (currentRequire) => {
    const MAX_TRIES = 50;
    let i = 0;
    let notClear = true;
    while (notClear && i < MAX_TRIES) {
        try {
            currentRequire([]);
            notClear = false;
        } catch {
            i++;
        }
    }
};
export const isNoEvalWorkaroundExperimentOn = (isExperimentOpen) => typeof isExperimentOpen !== 'undefined' &&
    isExperimentOpen ? .(consts.experiments.noEvalWorkaround);
const parseDefineArguments = (...args) => {
    if (args.length === 3) {
        return {
            id: args[0],
            deps: args[1],
            factory: args[2],
        };
    } else if (args.length === 2) {
        return {
            id: typeof args[0] === 'string' ? args[0] : null,
            deps: Array.isArray(args[0]) ? args[0] : [],
            factory: args[1],
        };
    } else {
        return null;
    }
};

function wrapDefineFunction(params) {
    /**
     * If components library was bundled with "umdNamedDefine: true", the UMD header in bundle will be:
     * ...
     * define('bundleId', [], factory)
     * ...
     *
     * If components "umdNamedDefine: false":
     * ...
     * define([], factory)
     * ...
     *
     * So this is anonymous define call, that means that it is not possible to require it after the evaluation
     * Better to track these cases.
     */
    let defineForBundle;
    if (params.define) {
        defineForBundle = (...args) => {
            const parsed = parseDefineArguments(...args);
            if (!parsed) {
                throw new Error('x');
            }
            const {
                id,
                deps,
                factory
            } = parsed;
            const globals = params.globals;
            const filteredDeps = deps.filter(key => !globals || (globals && !globals[key]));
            if (globals) {
                params.define(id, filteredDeps, (...values) => {
                    const allValues = deps.map(dep => {
                        const index = filteredDeps.findIndex(_dep => _dep === dep);
                        if (index === -1) {
                            return globals[dep];
                        } else {
                            return values[index];
                        }
                    });
                    return factory(...allValues);
                });
            } else {
                params.define(...args);
            }
        };
        defineForBundle.amd = params.define.amd;
    }
    return defineForBundle;
}

function getDefineFunction() {
    const currentGlobal = getGlobal();
    return typeof currentGlobal.define === 'function' && currentGlobal.define.amd ?
        currentGlobal.define :
        null;
}
export function getEnvironment({
    id,
    globals,
    isExperimentOpen,
}) {
    const currentGlobal = getGlobal();
    const _define = getDefineFunction();
    let self = currentGlobal;
    if (globals && !_define) {
        self = new Proxy(currentGlobal, {
            get(target, key) {
                const store = key in globals ? globals : target;
                const value = store[key];
                if (typeof value === 'function') {
                    const returnValue = (...args) => value.apply(store, args);
                    Object.assign(returnValue, value);
                    return returnValue;
                } else {
                    return value;
                }
            },
        });
    }
    const currentRequire = getOriginalRequireFunction(isExperimentOpen);
    return {
        /**
         * for requirejs environment
         */
        define: wrapDefineFunction({
            id,
            define: _define,
            globals
        }),
        /**
         * `workaround.require` – always default require function
         * for SSR – it is node require
         * for CSR – it is requirejs
         */
        require: currentRequire ?
            name => {
                if (globals && globals[name]) {
                    return globals[name];
                }
                return currentRequire(name);
            } :
            undefined,
        /**
         * always force `module` to be undefine during bundle evaluation
         */
        module: undefined,
        /**
         * commonjs & commonjs2
         *
         * for server env. we provide `exports` as plain object
         * after evaluation, it is possible to get the results:
         * env.exports[bundleId]
         */
        exports: isServer() && isOriginalRequireFunctionAvailable(isExperimentOpen) ?
            {} :
            undefined,
        /**
         *
         */
        self,
    };
}
export function getGlobalModel(id, isExperimentOpen) {
    const env = getEnvironment({
        id,
        isExperimentOpen
    });
    const model = env.self[id];
    if (!model && typeof env.define === 'function') {
        return requireAMDModule(id, isExperimentOpen);
    }
    return model;
}
export function getModelFromContext(id, context) {
    if (!context) {
        return null;
    }
    const lazyFactoryID = getLazyFactoryID(id);
    const factory = context[lazyFactoryID];
    if (factory && !factory.invoked) {
        factory.invoked = true;
        factory();
    }
    return context[id];
}
export async function getModel(id, isExperimentOpen) {
    const factory = await getGlobalModel(getLazyFactoryID(id), isExperimentOpen);
    if (factory && !factory.invoked) {
        factory.invoked = true;
        factory();
    }
    /**
     * Probably we need to check pending script tags
     */
    return getGlobalModel(id, isExperimentOpen);
}
export function evaluateBundle(bundle, {
    id,
    globals,
    contexts,
    useExperimentalEval,
    isExperimentOpen,
} = {}) {
    const env = getEnvironment({
        id,
        globals,
        isExperimentOpen
    });
    if (useExperimentalEval) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            (function({
                define,
                require,
                module,
                exports,
                self
            }) {
                eval(`${bundle}
  //# sourceURL=webpack-internal://`);
            })(env);
        } catch (error) {
            throw createException(RegistryErrorCode.Unknown);
        }
    } else {
        const evaluateBundleSources = new Function('define', 'require', 'module', 'exports', 'self', bundle);
        evaluateBundleSources(env.define, env.require, env.module, env.exports, env.self);
    }
    if (!id) {
        return;
    }
    if (typeof env.exports === 'object') {
        contexts[id] = env.exports;
    }
}
//# sourceMappingURL=evaluateBundle.js.map