import {
    __assign,
    __extends,
    __spreadArray
} from "tslib";
import {
    isArray,
    isFunction
} from './type-utils';
import clone from './clone';
import {
    FilterValidator
} from './filter-validator';
import {
    optimisedQuery
} from './query-optimiser';
var filterMixin = function(Base) {
    if (Base === void 0) {
        Base = (function() {
            function class_1() {}
            return class_1;
        }());
    }
    return (function(_super) {
        __extends(class_2, _super);

        function class_2(obj) {
            if (obj === void 0) {
                obj = {};
            }
            var _this = _super.call(this, obj) || this;
            _this.filterTree = obj.filterTree || {
                $and: []
            };
            _this.invalidArguments = obj.invalidArguments || [];
            _this.encoder = obj.encoder || {};
            return _this;
        }
        class_2.prototype.eq = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._binaryAnd('$eq', '.eq', args);
        };
        class_2.prototype.ne = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._binaryAnd('$ne', '.ne', args);
        };
        class_2.prototype.ge = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._AndLogicalEquivalence('$gte', '.ge', args);
        };
        class_2.prototype.gt = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._AndLogicalEquivalence('$gt', '.gt', args);
        };
        class_2.prototype.le = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._AndLogicalEquivalence('$lte', '.le', args);
        };
        class_2.prototype.lt = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._AndLogicalEquivalence('$lt', '.lt', args);
        };
        class_2.prototype.isNotEmpty = function(field) {
            var _a = this._filterValidator('.isNotEmpty')
                .arityIsOne(arguments)
                .validFieldName(field)
                .validateAndAggregate(),
                newInvalidArguments = _a[0],
                valid = _a[1];
            if (valid) {
                return this.ne(field, null);
            }
            return this._copy(this.filterTree, newInvalidArguments);
        };
        class_2.prototype.isEmpty = function(field) {
            var _a = this._filterValidator('.isEmpty')
                .arityIsOne(arguments)
                .validFieldName(field)
                .validateAndAggregate(),
                newInvalidArguments = _a[0],
                valid = _a[1];
            if (valid) {
                return this.eq(field, null);
            }
            return this._copy(this.filterTree, newInvalidArguments);
        };
        class_2.prototype.startsWith = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._AndStringOperand('$startsWith', '.startsWith', args);
        };
        class_2.prototype.endsWith = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._AndStringOperand('$endsWith', '.endsWith', args);
        };
        class_2.prototype.contains = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._AndStringOperand('$contains', '.contains', args);
        };
        class_2.prototype.hasSome = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._AndSetOperand('$hasSome', '.hasSome', args);
        };
        class_2.prototype.hasAll = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return this._AndSetOperand('$hasAll', '.hasAll', args);
        };
        class_2.prototype.or = function(orQuery) {
            var _a = this._filterValidator('.or')
                .arityIsOne(arguments)
                .isInstanceOfSameClass(orQuery)
                .validateAndAggregate(),
                newInvalidArguments = _a[0],
                valid = _a[1];
            if (valid) {
                var prefix = isEmptyAnd(this.filterTree) ? [] : [this.filterTree];
                return this._copy(inAnd({
                    $or: __spreadArray(__spreadArray([], prefix, true), [orQuery.filterTree], false)
                }), newInvalidArguments.concat(orQuery.invalidArguments));
            } else {
                return this._copy(this.filterTree, newInvalidArguments);
            }
        };
        class_2.prototype.and = function(andQuery) {
            var _a = this._filterValidator('.and')
                .arityIsOne(arguments)
                .isInstanceOfSameClass(andQuery)
                .validateAndAggregate(),
                newInvalidArguments = _a[0],
                valid = _a[1];
            if (valid) {
                var prefix = isEmptyAnd(this.filterTree) ? [] : [this.filterTree];
                return this._copy(inAnd.apply(void 0, __spreadArray(__spreadArray([], prefix, false), [andQuery.filterTree], false)), newInvalidArguments.concat(andQuery.invalidArguments));
            } else {
                return this._copy(this.filterTree, newInvalidArguments);
            }
        };
        class_2.prototype.not = function(notQuery) {
            var _a = this._filterValidator('.not')
                .arityIsOne(arguments)
                .isInstanceOfSameClass(notQuery)
                .validateAndAggregate(),
                newInvalidArguments = _a[0],
                valid = _a[1];
            if (valid) {
                var newFilterTree = clone(this.filterTree);
                var notClause = {
                    $not: [notQuery.filterTree]
                };
                var resultingFilter = inAndOptimized(newFilterTree, notClause);
                return this._copy(resultingFilter, newInvalidArguments.concat(notQuery.invalidArguments));
            } else {
                return this._copy(this.filterTree, newInvalidArguments);
            }
        };
        class_2.prototype.between = function(field, rangeStart, rangeEnd) {
            var _a = this._filterValidator('.between')
                .arityIsThree(arguments)
                .sameType(rangeStart, rangeEnd)
                .typeIsStringNumberOrDate(rangeStart)
                .typeIsStringNumberOrDate(rangeEnd)
                .validateAndAggregate(),
                newInvalidArguments = _a[0],
                valid = _a[1];
            if (valid) {
                return this.ge(field, rangeStart).lt(field, rangeEnd);
            }
            return this._copy(this.filterTree, newInvalidArguments);
        };
        class_2.prototype.getFilterModel = function() {
            if (this.invalidArguments.length > 0) {
                throw new Error(this.invalidArguments.join(' '));
            }
            return optimisedQuery(this.filterTree);
        };
        class_2.prototype.setFilterModel = function(filterModel) {
            return this._copy(filterModel, []);
        };
        class_2.prototype._binaryAnd = function(filterOperatorSymbol, operatorName, args) {
            var _a = Array.prototype.slice.call(args),
                field = _a[0],
                operand = _a[1];
            var newInvalidArguments = this._filterValidator(operatorName)
                .arityIsTwo(args)
                .validFieldName(field)
                .validateAndAggregate()[0];
            var newFilterTree = this._makeNewFilter(field, filterOperatorSymbol, operand);
            return this._copy(newFilterTree, newInvalidArguments);
        };
        class_2.prototype._AndLogicalEquivalence = function(filterOperatorSymbol, operatorName, args) {
            var _a = Array.prototype.slice.call(args),
                field = _a[0],
                operand = _a[1];
            var newInvalidArguments = this._filterValidator(operatorName)
                .arityIsTwo(args)
                .validFieldName(field)
                .typeIsStringNumberOrDate(operand)
                .validateAndAggregate()[0];
            var newFilterTree = this._makeNewFilter(field, filterOperatorSymbol, operand);
            return this._copy(newFilterTree, newInvalidArguments);
        };
        class_2.prototype._AndStringOperand = function(filterOperatorName, operatorName, args) {
            var _a = Array.prototype.slice.call(args),
                field = _a[0],
                operand = _a[1];
            var newInvalidArguments = this._filterValidator(operatorName)
                .arityIsTwo(args)
                .validFieldName(field)
                .typeIsString(operand)
                .validateAndAggregate()[0];
            var newFilterTree = this._makeNewFilter(field, filterOperatorName, operand);
            return this._copy(newFilterTree, newInvalidArguments);
        };
        class_2.prototype._AndSetOperand = function(filterOperatorName, operatorName, args) {
            var _a = Array.prototype.slice.call(args),
                field = _a[0],
                rawOperands = _a.slice(1);
            var operands = isArray(rawOperands[0]) ? rawOperands[0] : rawOperands;
            var newInvalidArguments = this._filterValidator(operatorName)
                .arityIsAtLeastTwo(args)
                .validFieldName(field)
                .typeIsStringNumberOrDateForAll(operands)
                .validateAndAggregate()[0];
            var newFilterTree = this._makeNewFilter(field, filterOperatorName, operands);
            return this._copy(newFilterTree, newInvalidArguments);
        };
        class_2.prototype._makeNewFilter = function(field, filterOperatorName, operand) {
            var newFilterTree = clone(this.filterTree);
            var serializableOperand = operand === undefined ? null : operand;
            var newFilter = this._buildFilter(field, filterOperatorName, serializableOperand);
            if (isArray(newFilterTree.$and)) {
                newFilterTree.$and.push(newFilter);
                return newFilterTree;
            } else {
                var result = isEmptyObject(newFilterTree) ?
                    inAnd(newFilter) :
                    inAnd(newFilterTree, newFilter);
                return result;
            }
        };
        class_2.prototype._buildFilter = function(field, filterOperatorName, operand) {
            if (filterOperatorName !== '$eq') {
                var newFilter = {};
                newFilter[field] = {};
                newFilter[field][filterOperatorName] = this._encode(operand);
                return newFilter;
            } else {
                var newFilter = {};
                newFilter[field] = this._encode(operand);
                return newFilter;
            }
        };
        class_2.prototype._encode = function(operand) {
            if (isFunction(this.encoder)) {
                return this.encoder(operand);
            } else {
                return operand;
            }
        };
        class_2.prototype._copy = function(filterTree, invalidArguments) {
            return new this.constructor(__assign(__assign({}, this), {
                filterTree: filterTree,
                invalidArguments: invalidArguments
            }));
        };
        class_2.prototype._filterValidator = function(filterOperatorName) {
            return new FilterValidator(filterOperatorName, this.invalidArguments, this.constructor);
        };
        return class_2;
    }(Base));
};

function isConjunctiveFormFilter(filterTree) {
    return isArray(filterTree.$and);
}

function isEmptyObject(obj) {
    return Object.keys(obj).length === 0;
}

function inAnd() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return {
        $and: args,
    };
}

function inAndOptimized() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return {
        $and: args.reduce(function(aggr, val) {
            return isConjunctiveFormFilter(val) ?
                aggr.concat(val.$and) :
                aggr.concat([val]);
        }, []),
    };
}

function isEmptyAnd(node) {
    return node && node.$and && node.$and.length === 0;
}
export default filterMixin;
//# sourceMappingURL=filter-mixin.js.map