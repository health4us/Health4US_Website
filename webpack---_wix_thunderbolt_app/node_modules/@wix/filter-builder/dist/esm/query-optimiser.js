import {
    __assign,
    __spreadArray
} from "tslib";
var optimisations = [
    optimisedUnaryAnd,
    optimisedEmptyAnd,
    optimisedAndsAsObjects,
    optimisedNestedAnds,
    optimisedNestedOrs,
];
export function optimisedQuery(query) {
    var newQuery = fullyOptimised(query)[0];
    return newQuery;
}

function fullyOptimised(query) {
    if (Array.isArray(query)) {
        return fullyOptimisedArray(query);
    }
    if (typeof query === 'object' &&
        query !== null &&
        !instanceOfIgnoredType(query)) {
        return fullyOptimisedObject(query);
    }
    return [query, false];
}

function fullyOptimisedArray(query) {
    var optimisedElements = query.map(fullyOptimised);
    var somethingChanged = 0 < optimisedElements.filter(function(_a) {
        var elementChanged = _a[1];
        return elementChanged;
    }).length;
    var newElements = optimisedElements.map(function(_a) {
        var element = _a[0];
        return element;
    });
    return [newElements, somethingChanged];
}

function fullyOptimisedObject(query) {
    var _a = fullEntriesOptimisation(query),
        queryAfterOptimisingEntries = _a[0],
        changedStage1 = _a[1];
    var _b = fullObjectOptimisation(queryAfterOptimisingEntries),
        queryAfterFullOptimisation = _b[0],
        changedStage2 = _b[1];
    var changed = changedStage1 || changedStage2;
    return [queryAfterFullOptimisation, changed];

    function fullObjectOptimisation(query) {
        var updatedQuery = applyFirstOptimisation(query);
        if (!updatedQuery) {
            return [query, false];
        }
        var finalQuery = fullyOptimised(updatedQuery)[0];
        return [finalQuery, true];
    }

    function fullEntriesOptimisation(query) {
        var changedEntries = Object.entries(query)
            .map(entryOptimisation)
            .filter(function(_a) {
                var changed = _a[2];
                return changed;
            });
        var newQuery = __assign(__assign({}, query), entriesAsObject(changedEntries));
        var changed = !!changedEntries.length;
        return [newQuery, changed];
    }

    function entryOptimisation(_a) {
        var key = _a[0],
            value = _a[1];
        var _b = fullyOptimised(value),
            newValue = _b[0],
            changed = _b[1];
        return [key, newValue, changed];
    }

    function entriesAsObject(entries) {
        return entries.reduce(function(acc, _a) {
            var _b;
            var key = _a[0],
                value = _a[1];
            return (__assign(__assign({}, acc), (_b = {}, _b[key] = value, _b)));
        }, {});
    }
}

function applyFirstOptimisation(node) {
    for (var _i = 0, optimisations_1 = optimisations; _i < optimisations_1.length; _i++) {
        var optimisation = optimisations_1[_i];
        var newNode = optimisation(node);
        if (newNode) {
            return newNode;
        }
    }
}

function optimisedUnaryAnd(node) {
    var args = node.$and;
    if (Array.isArray(args) && args.length === 1) {
        return args[0];
    }
}

function optimisedEmptyAnd(node) {
    var args = node.$and;
    if (Array.isArray(args) && args.length === 0) {
        return {};
    }
    return null;
}

function optimisedAndsAsObjects(node) {
    var args = node.$and;
    if (!args) {
        return;
    }
    var basicObjects = [];
    var operatorObjects = [];
    args.forEach(function(arg) {
        if (isOperator(arg)) {
            operatorObjects = __spreadArray(__spreadArray([], operatorObjects, true), [arg], false);
        } else {
            basicObjects = __spreadArray(__spreadArray([], basicObjects, true), [arg], false);
        }
    });
    if (basicObjects.length <= 1 || haveOverlappingFields(basicObjects)) {
        return;
    }
    var combinedBasicObjects = Object.assign.apply(Object, __spreadArray([{}], basicObjects, false));
    return {
        $and: __spreadArray([combinedBasicObjects], operatorObjects, true)
    };

    function isOperator(node) {
        var keys = Object.keys(node);
        return keys.every(function(name) {
            return name.startsWith('$');
        }) && keys.length > 0;
    }

    function haveOverlappingFields(objects) {
        var nonUniqueKeys = objects
            .map(function(it) {
                return Object.keys(it);
            })
            .reduce(function(a, b) {
                return __spreadArray(__spreadArray([], a, true), b, true);
            }, []);
        var uniqueKeys = unique(nonUniqueKeys);
        return uniqueKeys.length !== nonUniqueKeys.length;
    }

    function unique(values) {
        var dict = {};
        values.forEach(function(v) {
            return (dict[v] = true);
        });
        return Object.keys(dict);
    }
}

function optimisedNestedAnds(node) {
    var args = node.$and;
    if (!args) {
        return;
    }
    var hasNestedAnds = !!args.find(function(it) {
        return it.$and;
    });
    if (!hasNestedAnds) {
        return;
    }
    var newArgs = args.reduce(function(result, current) {
        var and = current.$and;
        if (!and) {
            return __spreadArray(__spreadArray([], result, true), [current], false);
        }
        return __spreadArray(__spreadArray([], result, true), and, true);
    }, []);
    return {
        $and: newArgs
    };
}

function optimisedNestedOrs(node) {
    var args = node.$or;
    if (!args) {
        return;
    }
    var hasNestedOrs = !!args.find(function(it) {
        return it.$or;
    });
    if (!hasNestedOrs) {
        return;
    }
    var newArgs = args.reduce(function(result, current) {
        var or = current.$or;
        if (!or) {
            return __spreadArray(__spreadArray([], result, true), [current], false);
        }
        return __spreadArray(__spreadArray([], result, true), or, true);
    }, []);
    return {
        $or: newArgs
    };
}

function instanceOfIgnoredType(obj) {
    return obj instanceof Date;
}
//# sourceMappingURL=query-optimiser.js.map