import {
    typeForDisplay,
    isDate,
    isString,
    isNumber
} from './type-utils';
import clone from './clone';
var FilterValidator = (function() {
    function FilterValidator(operatorName, previousInvalidArguments, ctor) {
        this._validations = [];
        this.operatorName = operatorName;
        this.ctor = ctor;
        this._invalidArguments = clone(previousInvalidArguments);
    }
    FilterValidator.prototype.typeIsString = function(value) {
        var _this = this;
        return this.addValidation(function() {
            return isString(value);
        }, function() {
            return "Invalid ".concat(_this.operatorName, " parameter value [").concat(typeForDisplay(value), "]. ").concat(_this.operatorName, " parameter must be a String.");
        });
    };
    FilterValidator.prototype.typeIsStringNumberOrDate = function(value) {
        var _this = this;
        return this.addValidation(function() {
            return isDateStringOrNumber(value);
        }, function() {
            return "Invalid ".concat(_this.operatorName, " parameter value [").concat(typeForDisplay(value), "]. Valid ").concat(_this.operatorName, " parameter types are String, Number or Date.");
        });
    };
    FilterValidator.prototype.sameType = function(first, second) {
        var _this = this;
        return this.addValidation(function() {
            return typeForDisplay(first) === typeForDisplay(second);
        }, function() {
            return "Invalid ".concat(_this.operatorName, " parameter values [").concat(typeForDisplay(first), "] and [").concat(typeForDisplay(second), "]. Both parameters must be of the same type.");
        });
    };
    FilterValidator.prototype.typeIsStringNumberOrDateForAll = function(values) {
        var _this = this;
        return this.addValidation(function() {
            return values.every(isDateStringOrNumber);
        }, function() {
            return "Invalid ".concat(_this.operatorName, " usage. ").concat(_this.operatorName, " supports only Number, String or Date items.");
        });
    };
    FilterValidator.prototype.validFieldName = function(field) {
        var _this = this;
        return this.addValidation(function() {
            return isString(field);
        }, function() {
            return "Invalid ".concat(_this.operatorName, " field value [").concat(typeForDisplay(field), "]. ").concat(_this.operatorName, " field must be a String.");
        });
    };
    FilterValidator.prototype.isInstanceOfSameClass = function(obj) {
        var _this = this;
        return this.addValidation(function() {
            return obj instanceof _this.ctor;
        }, function() {
            return "Invalid ".concat(_this.operatorName, " parameter [").concat(typeForDisplay(obj), "]. ").concat(_this.operatorName, " expects FilterBuilder only.");
        });
    };
    FilterValidator.prototype.arityIsOne = function(args) {
        var _this = this;
        return this.addValidation(function() {
            return args.length === 1;
        }, function() {
            return "Invalid ".concat(_this.operatorName, " usage. ").concat(_this.operatorName, " requires one parameter.");
        });
    };
    FilterValidator.prototype.arityIsTwo = function(args) {
        var _this = this;
        return this.addValidation(function() {
            return args.length === 2;
        }, function() {
            return "Invalid ".concat(_this.operatorName, " usage. ").concat(_this.operatorName, " requires two parameters.");
        });
    };
    FilterValidator.prototype.arityIsThree = function(args) {
        var _this = this;
        return this.addValidation(function() {
            return args.length === 3;
        }, function() {
            return "Invalid ".concat(_this.operatorName, " usage. ").concat(_this.operatorName, " requires three parameters.");
        });
    };
    FilterValidator.prototype.arityIsAtLeastTwo = function(args) {
        var _this = this;
        return this.addValidation(function() {
            return args.length >= 2;
        }, function() {
            return "Invalid ".concat(_this.operatorName, " usage. ").concat(_this.operatorName, " requires at least two parameters.");
        });
    };
    FilterValidator.prototype.addValidation = function(predicateFn, messageFn) {
        this._validations.push({
            predicateFn: predicateFn,
            messageFn: messageFn,
        });
        return this;
    };
    FilterValidator.prototype.validateAndAggregate = function() {
        var _this = this;
        var valid = this._validations.every(function(_a) {
            var predicateFn = _a.predicateFn,
                messageFn = _a.messageFn;
            return _this._appendIfInvalid(predicateFn(), messageFn());
        });
        return [this._invalidArguments, valid];
    };
    FilterValidator.prototype._appendIfInvalid = function(valid, message) {
        if (!valid) {
            this._invalidArguments.push(message);
            return false;
        }
        return true;
    };
    return FilterValidator;
}());
export {
    FilterValidator
};

function isDateStringOrNumber(value) {
    return isString(value) || isNumber(value) || isDate(value);
}
//# sourceMappingURL=filter-validator.js.map