import {
    typeForDisplay
} from '@wix/wix-data-utils';
import {
    UserCodeError
} from '@wix/cloud-base-errors-definitions';
import safeJsonStringify from 'safe-json-stringify';

function stringify(obj) {
    return safeJsonStringify(obj);
}
// When adding new messages, update Support article with error code and explanation about the error.
export var messages = {
    collectionNameMustBeAString: function() {
        return 'WDE0001: Collection name must be a string.';
    },
    itemIdMustBeAString: function() {
        return 'WDE0002: ItemId must be a string.';
    },
    itemIdsMustBeArrayOfStrings: function() {
        return 'WDE0068: Item ids must be an array of strings';
    },
    removeItemsMustBeLessThanThousand: function(collectionName) {
        return "WDE0069: Failed to remove items from [".concat(collectionName, "].\nCannot remove more than 1000 items in one request");
    },
    fieldNameMustBeAString: function() {
        return 'WDE0003: FieldName must be a string.';
    },
    itemMustBeAnObject: function(item, collectionName) {
        return "WDE0004: Failed to save [".concat(item, "] into [").concat(collectionName, "].\nItems must be JavaScript objects.");
    },
    itemsMustBeArrayOfObjects: function(collectionName) {
        return "WDE0005: Failed to bulk save items into [".concat(collectionName, "].\nItems must be an array of JavaScript objects and itemIds must be strings if present.");
    },
    itemsMustBeLessThanThousand: function(collectionName) {
        return "WDE0006: Failed to bulk save items into [".concat(collectionName, "].\nCannot insert more than 1000 items in one request");
    },
    updateItemInvalid: function() {
        return 'WDE0007: Invalid update. Updated object must have a string _id property.';
    },
    invalidArgumentLength: function(method, from, to, actual) {
        return "WDE0008: wixData.".concat(method, " expects between ").concat(from, " and ").concat(to, " arguments, but was called with ").concat(actual, ".");
    },
    documentTooLarge: function() {
        return 'WDE0009: Document is too large.';
    },
    keyTooLargeToIndex: function() {
        return 'WDE0010: Document field is too large to index.';
    },
    aggregateValidations: {
        aggregateInvalid: function(collectionName, invalidArguments) {
            return "Failed to perform aggregation on [".concat(collectionName, "].\n").concat(invalidArguments.join('\n'));
        },
        filterMustBeBuilder: function(operatorName) {
            return "WDE0011: Invalid ".concat(operatorName, " usage. ").concat(operatorName, " requires WixDataFilter.");
        },
        filterIsAlreadySet: function(operatorName) {
            return "WDE0012: Invalid ".concat(operatorName, " usage. Filter is already set.");
        },
        groupIsAlreadySet: function(operatorName) {
            return "WDE0013: Invalid ".concat(operatorName, " usage. Group is already set.");
        },
    },
    filterBuilderInvalid: function(invalidArguments) {
        return "Failed to build a filter.\n".concat(invalidArguments.join('\n'), ".");
    },
    groupBuilderInvalid: function(invalidArguments) {
        return "Failed to build group.\n".concat(invalidArguments.join('\n'), ".");
    },
    filterMustBeAnObject: function() {
        return 'WDE0016: Filter must be an object.';
    },
    sortBuilderInvalid: function(invalidArguments) {
        return "Failed to build a sort.\n".concat(invalidArguments.join('\n'), ".");
    },
    optionsInvalid: function(properties) {
        return "WDE0018: Options must be an object with one or all of the following boolean properties: ".concat(properties.join(', '), ".");
    },
    referenceOperationParameterError: function() {
        return 'WDE0019: Reference operation takes a string ID or an object with an ID to be connected.';
    },
    referenceOperationFieldError: function(fieldName) {
        return "WDE0020: Provided property [".concat(fieldName, "] is not a multi-reference field.");
    },
    invalidReferenceError: function() {
        return "WDE0021: Invalid reference";
    },
    multipleMultiRefIncludeError: function() {
        return 'WDE0022: Unable to execute a query. Only single multi-reference field can be included.';
    },
    multiRefItemLimitError: function() {
        return 'WDE0023: Can not fetch more than 50 elements when include is being used on multi-reference field';
    },
    fieldIsDeleted: function() {
        return 'WDE0024: Field is deleted';
    },
    schemaDoesNotExist: function(collectionName) {
        return "WDE0025: The ".concat(collectionName, " collection does not exist. You cannot work with a collection using the Data API before it is created in the Editor.");
    },
    collectionDeleted: function(collectionName) {
        return "WDE0026: The ".concat(collectionName, " collection was removed, so you cannot work with it. To restore its data, create a new collection with the same name.");
    },
    permissionDenied: function(action, collectionName) {
        return "WDE0027: The current user does not have permissions to ".concat(action, " on the ").concat(collectionName, " collection.");
    },
    requestTimedOut: function() {
        return "WDE0028: Operation time limit exceeded.";
    },
    internalAuthorizationProblem: function() {
        return 'WDE0029: An internal error has occurred while trying to check authorization.';
    },
    queryValidations: {
        queryInvalid: function(collectionName, invalidArguments) {
            return "Failed to perform query on [".concat(collectionName, "].\n").concat(invalidArguments.join('\n'));
        },
        isNumber: function(operatorName, specifier, operand) {
            return "WDE0032: Invalid ".concat(operatorName, " parameter [").concat(typeForDisplay(operand), "]. ").concat(operatorName, " parameter must be a ").concat(specifier, " number.");
        },
        isPositiveNumber: function(operatorName, operand) {
            return "WDE0033: Invalid ".concat(operatorName, " parameter [").concat(operand, "]. ").concat(operatorName, " parameter must be a positive number.");
        },
        isNonNegativeNumber: function(operatorName, operand) {
            return "WDE0034: Invalid ".concat(operatorName, " parameter [").concat(operand, "]. ").concat(operatorName, " parameter must be a non-negative number.");
        },
        isInteger: function(operatorName, operand) {
            return "WDE0035: Invalid ".concat(operatorName, " parameter [").concat(operand, "]. ").concat(operatorName, " parameter must be an integer.");
        },
        isNonEmptyString: function(operatorName) {
            return "WDE0094: Invalid ".concat(operatorName, " parameter. ").concat(operatorName, " parameter must be non-empty string.");
        },
        notGreaterThan: function(operatorName, operand, value) {
            return "WDE0036: Invalid ".concat(operatorName, " parameter [").concat(operand, "]. ").concat(operatorName, " parameter cannot exceed ").concat(value, ".");
        },
        invalidSkipParameter: function(collectionName, skipParameter) {
            return "WDE0037: Invalid query on [".concat(collectionName, "].\nInvalid prev positioned query skip on a negative number ").concat(skipParameter, ".");
        },
        noPrevPage: function(collectionName) {
            return "WDE0159: Invalid query on [".concat(collectionName, "].\nThere is no prev page.");
        },
        noNextPage: function(collectionName) {
            return "WDE0165: Invalid query on [".concat(collectionName, "].\nThere is no next page.");
        },
    },
    arityValidations: {
        arityIsZero: function(operatorName) {
            return "WDE0038: Invalid ".concat(operatorName, " usage. ").concat(operatorName, " does not take parameters.");
        },
        arityIsOne: function(operatorName) {
            return "WDE0039: Invalid ".concat(operatorName, " usage. ").concat(operatorName, " requires one parameter.");
        },
        arityIsTwo: function(operatorName) {
            return "WDE0040: Invalid ".concat(operatorName, " usage. ").concat(operatorName, " requires two parameters.");
        },
        arityIsThree: function(operatorName) {
            return "WDE0041: Invalid ".concat(operatorName, " usage. ").concat(operatorName, " requires three parameters.");
        },
        arityIsAtLeastTwo: function(operatorName) {
            return "WDE0042: Invalid ".concat(operatorName, " usage. ").concat(operatorName, " requires at least two parameters.");
        },
        arityIsAtLeastOne: function(operatorName) {
            return "WDE0043: Invalid ".concat(operatorName, " usage. ").concat(operatorName, " requires at least one parameter.");
        },
    },
    filterValidations: {
        typeIsString: function(operatorName, value) {
            return "WDE0044: Invalid ".concat(operatorName, " parameter value [").concat(typeForDisplay(value), "]. ").concat(operatorName, " parameter must be a String.");
        },
        typeIsStringNumberOrDate: function(operatorName, value) {
            return "WDE0045: Invalid ".concat(operatorName, " parameter value [").concat(typeForDisplay(value), "]. Valid ").concat(operatorName, " parameter types are String, Number or Date.");
        },
        sameType: function(operatorName, first, second) {
            return "WDE0046: Invalid ".concat(operatorName, " parameter values [").concat(typeForDisplay(first), "] and [").concat(typeForDisplay(second), "]. Both parameters must be of the same type.");
        },
        typeIsStringNumberOrDateForAll: function(operatorName) {
            return "WDE0047: Invalid ".concat(operatorName, " usage. ").concat(operatorName, " supports only Number, String or Date items.");
        },
        validFieldName: function(operatorName, field) {
            return "WDE0048: Invalid ".concat(operatorName, " field value [").concat(typeForDisplay(field), "]. ").concat(operatorName, " field must be a String.");
        },
        isInstanceOfSameClass: function(operatorName, constructorName, obj) {
            return "WDE0049: Invalid ".concat(operatorName, " parameter [").concat(typeForDisplay(obj), "]. ").concat(operatorName, " expects ").concat(constructorName, " only.");
        },
        isForCollection: function(operatorName, constructorName, collectionName) {
            return "WDE0050: Invalid ".concat(operatorName, " parameter query for [").concat(collectionName, "]. ").concat(operatorName, " accepts ").concat(constructorName, " for the same collection only.");
        },
        incorrectDraftPublishFilter: function() {
            return "WDE0093: Invalid filter for _publishStatus field, only .eq and .ne filters are allowed with 'DRAFT' and 'PUBLISHED' possible values.";
        },
    },
    filterTreeValidationsAjv: {
        objectType: function(operatorName) {
            return "WDE0056: ".concat(operatorName, " should be an Object. Got ${0} instead");
        },
        arrayType: function(operatorName) {
            return "WDE0057: ".concat(operatorName, " should be an Array. Got ${0} instead");
        },
        arrayLength: function(operatorName, expectedLength) {
            return "WDE0057: ${0}.length is ${0/length}. ".concat(operatorName, " Array should have length ").concat(expectedLength);
        },
        comparisonOperatorType: function(operatorName) {
            return "WDE0058: ".concat(operatorName, " should be a Date, Number, or String. Got ${0} instead");
        },
        stringOperatorType: function(operatorName) {
            return "WDE0059: ".concat(operatorName, " should be a String. Got ${0} instead");
        },
        setOperatorItems: function(operatorName) {
            return "WDE0060: ".concat(operatorName, " Array should only contain values of types Date, Number, and String. Got ${0} instead");
        },
        inOperatorItems: function() {
            return "WDE0061: $in Array should have length 2, and match [String, Number]. Got ${0} instead";
        },
        matchesOperatorRequiredProperty: function(propertyName) {
            return "WDE0062: $matches value ${0} does not have property ".concat(propertyName);
        },
        matchesOperatorIgnoreCase: function() {
            return "WDE0063: $matches.ignoreCase should equal true. Got ${0/ignoreCase} instead";
        },
        matchesOperatorSpecItems: function() {
            return "WDE0064: $matches.spec Array values should be either {\"type\":\"anyOf\",\"value\":\" -\"} or {\"type\":\"literal\",\"value\":String}. Got ${0} instead";
        },
        regexNotAllowed: function() {
            return 'WDE0070: $regex keyword is not allowed.';
        },
    },
    filterTreeValidations: {
        objectType: function(operatorName, value) {
            return "WDE0056: ".concat(operatorName, " should be an Object. Got ").concat(stringify(value), " instead");
        },
        arrayType: function(operatorName, value) {
            return "WDE0057: ".concat(operatorName, " should be an Array. Got ").concat(stringify(value), " instead");
        },
        arrayLength: function(operatorName, expectedLength, value) {
            return "WDE0057: ".concat(stringify(value), ".length is ").concat(value.length, ". ").concat(operatorName, " Array should have length ").concat(expectedLength);
        },
        comparisonOperatorType: function(operatorName, value) {
            return "WDE0058: ".concat(operatorName, " should be a Date, Number, or String. Got ").concat(stringify(value), " instead");
        },
        stringOperatorType: function(operatorName, value) {
            return "WDE0059: ".concat(operatorName, " should be a String. Got ").concat(stringify(value), " instead");
        },
        setOperatorItems: function(operatorName, value) {
            return "WDE0060: ".concat(operatorName, " Array should only contain values of types Date, Number, and String. Got ").concat(stringify(value), " instead");
        },
        inOperatorItems: function(value) {
            return "WDE0061: $in Array should have length 2, and match [String, Number]. Got ".concat(stringify(value), " instead");
        },
        matchesOperatorRequiredProperty: function(propertyName, value) {
            return "WDE0062: $matches value ".concat(stringify(value), " does not have property ").concat(propertyName);
        },
        matchesOperatorIgnoreCase: function(value) {
            return "WDE0063: $matches.ignoreCase should equal true. Got ".concat(stringify(value), " instead");
        },
        matchesOperatorSpecItems: function(value) {
            return "WDE0064: $matches.spec Array values should be either {\"type\":\"anyOf\",\"value\":\" -\"} or {\"type\":\"literal\",\"value\":String}. Got ".concat(stringify(value), " instead");
        },
        regexNotAllowed: function() {
            return 'WDE0070: $regex keyword is not allowed.';
        },
    },
    sortValidations: {
        typeIsStringOrArrayOfStrings: function(operatorName, effectiveArgs) {
            return "WDE0051: Invalid ".concat(operatorName, " parameters [").concat(effectiveArgs.map(typeForDisplay), "]. Valid ").concat(operatorName, " values are String, Array of String or varargs String.");
        },
    },
    orderByValidationsAjv: {
        sortModelType: function() {
            return "WDE0065: Sort Model should be an Array. Got ${0} instead";
        },
        sortModelItemType: function() {
            return "WDE0066: Sort Model Array should contain values of type Object only. Got ${0} instead";
        },
        sortModelItem: function() {
            return "WDE0067: Sort Model Array items should have a single property with value \"asc\" or \"desc\". Got ${0} instead";
        },
    },
    orderByValidations: {
        sortModelType: function(value) {
            return "WDE0065: Sort Model should be an Array. Got ".concat(stringify(value), " instead");
        },
        sortModelItemType: function(value) {
            return "WDE0066: Sort Model Array should contain values of type Object only. Got ".concat(stringify(value), " instead");
        },
        sortModelItem: function(value) {
            return "WDE0067: Sort Model Array items should have a single property with value \"asc\" or \"desc\". Got ".concat(stringify(value), " instead");
        },
    },
    siteIsInTemplateMode: function() {
        return 'WDE0052: The current site is in template mode. Please save it to modify data.';
    },
    internalError: function(message) {
        return "WDE0053: Internal wixData error: ".concat(message);
    },
    serverGeneralError: function() {
        return 'WDE0054: The server could not fulfill the request.';
    },
    serverInvalidResponse: function() {
        return 'WDE0055: Failed to parse server response.';
    },
    tooManyRequests: function() {
        return 'WDE0014: Requests per minute quota exceeded.';
    },
    processingTimeQuotaExceeded: function() {
        return 'WDE0122: Processing time quota exceeded.';
    },
    operationNotSupported: function(collectionName, operation) {
        return "".concat(collectionName, " does not support ").concat(operation, " operation.");
    },
    databaseQuotaExceeded: function() {
        return 'WDE0091: Database quota exceeded. Delete some data and try again.';
    },
    itemDoesNotExist: function(id, collectionName) {
        return "WDE0073: Item [".concat(id, "] does not exist in collection [").concat(collectionName, "].");
    },
    invalidLimit: function(maxLimit) {
        return "WDE0077: 'limit' cannot exceed ".concat(maxLimit);
    },
    datasetTooLargeToSort: function() {
        return 'WDE0092: Dataset is too large to sort.';
    },
    invalidIdForSingleItemCollection: function(collectionName, expectedId, receivedId) {
        return "WDE0079: [".concat(collectionName, "] is a single item collection and item must have id [").concat(expectedId, "], but got [").concat(receivedId, "] instead.");
    },
    cursorPagingDoesNotSupportSkip: function() {
        return 'WDE0080: Skip is not supported in cursor paging.';
    },
    payloadIsTooLarge: function() {
        return 'WDE0109: Payload is too large.';
    },
    cannotSortMultipleArrayFields: function() {
        return 'WDE0121: Sorting by multiple array fields is not supported';
    },
};
export var codes = {
    ItemDoesNotExist: 'WD_ITEM_DOES_NOT_EXIST',
    ItemAlreadyExists: 'WD_ITEM_ALREADY_EXISTS',
    SiteInTemplateMode: 'WD_SITE_IN_TEMPLATE_MODE',
    UnknownError: 'WD_UNKNOWN_ERROR',
    ValidationError: 'WD_VALIDATION_ERROR',
    CollectionDeleted: 'WD_COLLECTION_DELETED',
    SchemaDoesNotExist: 'WD_SCHEMA_DOES_NOT_EXIST',
    PermissionDenied: 'WD_PERMISSION_DENIED',
    BadRequest: 'WD_BAD_REQUEST',
    Unauthorized: 'WD_UNAUTHORIZED',
    TooManyRequests: 'WD_TOO_MANY_REQUESTS',
    RequestTimedOut: 'WD_REQUEST_TIMED_OUT',
    QuotaExceeded: 'WD_DATABASE_QUOTA_EXCEEDED',
    QueryExecutionError: 'WD_QUERY_EXECUTION_ERROR',
};
// todo add code
export function wixDataError(message, code, details) {
    return errorWithCode(message, code, details);
}
export function validationError(message) {
    return errorWithCode(message, codes.ValidationError);
}
export var DATA_HOOK_ERROR_NAME = 'WixDataHookError';
export function isDataHookError(err) {
    return err instanceof Error && err.name === DATA_HOOK_ERROR_NAME;
}
export function dataHookError(err) {
    function buildObj(error) {
        if (error === undefined) {
            return {
                type: 'undefined'
            };
        } else if (error instanceof Error) {
            // @ts-ignore-next-line
            var name_1 = error.name,
                message = error.message,
                code = error.code;
            return {
                type: 'error',
                value: {
                    name: name_1,
                    message: message,
                    code: code
                }
            };
        } else {
            return {
                type: 'value',
                value: error
            };
        }
    }
    var errorInstance = new Error(stringify(buildObj(err)));
    errorInstance.name = DATA_HOOK_ERROR_NAME;
    // @ts-ignore-next-line
    errorInstance.originalError = err;
    if (Error.captureStackTrace) {
        Error.captureStackTrace(errorInstance, dataHookError);
    }
    return errorInstance;
}

function errorWithCode(message, code, details) {
    var ErrorConstructor = code && code !== codes.UnknownError ? WixDataError : Error;
    // @ts-ignore-next-line
    var error = new ErrorConstructor(message);
    error.code = code;
    if (details) {
        error.details = details;
    }
    return error;
}
export function schemaNotFoundError(collectionName) {
    return wixDataError(messages.schemaDoesNotExist(collectionName), codes.SchemaDoesNotExist);
}
export function BulkError(message, code, item, name, originalIndex) {
    var errorInstance = new Error(message);
    if (name) {
        errorInstance.name = name;
    }
    errorInstance.code = code;
    errorInstance.item = item;
    errorInstance.originalIndex = originalIndex;
    Object.setPrototypeOf(errorInstance, Object.getPrototypeOf(this));
    if (Error.captureStackTrace) {
        Error.captureStackTrace(errorInstance, BulkError);
    }
    return errorInstance;
}
BulkError.prototype = Object.create(Error.prototype, {
    constructor: {
        value: Error,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});

function WixDataError(message) {
    var errorInstance = new UserCodeError(message);
    Object.setPrototypeOf(errorInstance, Object.getPrototypeOf(this));
    if (Error.captureStackTrace) {
        Error.captureStackTrace(errorInstance, WixDataError);
    }
    errorInstance.name = Error.name;
    return errorInstance;
}
WixDataError.prototype = Object.create(UserCodeError.prototype, {
    constructor: {
        value: WixDataError,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
//# sourceMappingURL=errors.js.map